<html>
<style>
table, th, td, tr
{
    border: 1px solid black;
    border-collapse: collapse;
}
</style>

<h1>Enums</h1>
<b>Backend : </b><br/><br/>
<table>
<tr><th colspan=2>Backend</th></tr>
<tr><td>DX12</td><td></td></tr>
<tr><td>UE_5_3</td><td></td></tr>
<tr><td>WebGPU</td><td></td></tr>
<tr><td>Interpreter</td><td></td></tr>
</table>
<br/>

<b>DataFieldType : The type of a data field</b><br/><br/>
<table>
<tr><th colspan=2>DataFieldType</th></tr>
<tr><td>Int</td><td>int</td></tr>
<tr><td>Int2</td><td>int[2]</td></tr>
<tr><td>Int3</td><td>int[3]</td></tr>
<tr><td>Int4</td><td>int[4]</td></tr>
<tr><td>Uint</td><td>uint</td></tr>
<tr><td>Uint2</td><td>uint[2]</td></tr>
<tr><td>Uint3</td><td>uint[3]</td></tr>
<tr><td>Uint4</td><td>uint[4]</td></tr>
<tr><td>Float</td><td>float</td></tr>
<tr><td>Float2</td><td>float[2]</td></tr>
<tr><td>Float3</td><td>float[3]</td></tr>
<tr><td>Float4</td><td>float[4]</td></tr>
<tr><td>Bool</td><td>bool</td></tr>
<tr><td>Float4x4</td><td>float[4][4]</td></tr>
<tr><td>Uint_16</td><td>a 16 bit uint</td></tr>
<tr><td>Int_64</td><td>a 64 bit int</td></tr>
<tr><td>Uint_64</td><td>a 64 bit uint</td></tr>
<tr><td>Float_16</td><td>a 16 bit float</td></tr>
<tr><td>Count</td><td></td></tr>
</table>
<br/>

<b>VariableVisibility : The visibility of the variable</b><br/><br/>
<table>
<tr><th colspan=2>VariableVisibility</th></tr>
<tr><td>Internal</td><td>Internal to the technique.</td></tr>
<tr><td>Host</td><td>The host app has access.</td></tr>
<tr><td>User</td><td>The host app has access and it should also be exposed to the user through UI and Script, where possible.</td></tr>
<tr><td>Count</td><td></td></tr>
</table>
<br/>

<b>VariableUIHint : Hints about how the UI for a variable should look or act, if it is made into UI</b><br/><br/>
<table>
<tr><th colspan=2>VariableUIHint</th></tr>
<tr><td>Button</td><td>There should be a button that when pressed makes the value true for a single frame, else is false.</td></tr>
<tr><td>Color</td><td>This represents a color, so a color selector would be appropriate.</td></tr>
<tr><td>Drag</td><td>Use the DragX functions in imgui.</td></tr>
<tr><td>Slider</td><td>Use the SliderX functions in imgui.</td></tr>
<tr><td>Angle</td><td>This value is an angle.</td></tr>
<tr><td>Count</td><td></td></tr>
</table>
<br/>

<b>ConditionComparison : The comparison to make between the two condition values</b><br/><br/>
<table>
<tr><th colspan=2>ConditionComparison</th></tr>
<tr><td>IsFalse</td><td>Checks if value1 is false</td></tr>
<tr><td>IsTrue</td><td>Checks if value1 is true</td></tr>
<tr><td>Equals</td><td>Checks if the two values are the same</td></tr>
<tr><td>NotEquals</td><td>Checks if the two values are notthe same</td></tr>
<tr><td>LT</td><td>value1 < value2</td></tr>
<tr><td>LTE</td><td>value1 <= value2</td></tr>
<tr><td>GT</td><td>value1 > value2</td></tr>
<tr><td>GTE</td><td>value1 >= value2</td></tr>
<tr><td>Count</td><td></td></tr>
</table>
<br/>

<b>CooperativeVectorBufferLayout : Describe the format of a buffer for use in cooperative vectors</b><br/><br/>
<table>
<tr><th colspan=2>CooperativeVectorBufferLayout</th></tr>
<tr><td>RowMajor</td><td>D3D12_LINEAR_ALGEBRA_MATRIX_LAYOUT_ROW_MAJOR</td></tr>
<tr><td>ColMajor</td><td>D3D12_LINEAR_ALGEBRA_MATRIX_LAYOUT_COLUMN_MAJOR</td></tr>
<tr><td>MulOptimal</td><td>D3D12_LINEAR_ALGEBRA_MATRIX_LAYOUT_MUL_OPTIMAL</td></tr>
<tr><td>OuterProductOptimal</td><td>D3D12_LINEAR_ALGEBRA_MATRIX_LAYOUT_OUTER_PRODUCT_OPTIMAL</td></tr>
</table>
<br/>

<b>CooperativeVectorDataType : The data type stored. D3D12_LINEAR_ALGEBRA_DATATYPE</b><br/><br/>
<table>
<tr><th colspan=2>CooperativeVectorDataType</th></tr>
<tr><td>_sint16</td><td>D3D12_LINEAR_ALGEBRA_DATATYPE_SINT16</td></tr>
<tr><td>_uint16</td><td>D3D12_LINEAR_ALGEBRA_DATATYPE_UINT16</td></tr>
<tr><td>_sint32</td><td>D3D12_LINEAR_ALGEBRA_DATATYPE_SINT32</td></tr>
<tr><td>_uint32</td><td>D3D12_LINEAR_ALGEBRA_DATATYPE_UINT32</td></tr>
<tr><td>_float16</td><td>D3D12_LINEAR_ALGEBRA_DATATYPE_FLOAT16</td></tr>
<tr><td>_float32</td><td>D3D12_LINEAR_ALGEBRA_DATATYPE_FLOAT32</td></tr>
<tr><td>_sint8x4</td><td>D3D12_LINEAR_ALGEBRA_DATATYPE_SINT8_T4_PACKED</td></tr>
<tr><td>_uint8x4</td><td>D3D12_LINEAR_ALGEBRA_DATATYPE_UINT8_T4_PACKED</td></tr>
<tr><td>_uint8</td><td>D3D12_LINEAR_ALGEBRA_DATATYPE_UINT8</td></tr>
<tr><td>_sint8</td><td>D3D12_LINEAR_ALGEBRA_DATATYPE_SINT8</td></tr>
<tr><td>_float8_e4m3</td><td>D3D12_LINEAR_ALGEBRA_DATATYPE_FLOAT_E4M3. 8 bits: 1 sign, 4 exp, 3 mantissa.</td></tr>
<tr><td>_float8_e5m2</td><td>D3D12_LINEAR_ALGEBRA_DATATYPE_FLOAT_E5M2. 8 bits: 1 sign, 5 exp, 2 mantissa.</td></tr>
</table>
<br/>

<b>ShaderResourceType : The type of a shader resource</b><br/><br/>
<table>
<tr><th colspan=2>ShaderResourceType</th></tr>
<tr><td>Texture</td><td>Unordered Access View (Read/Write)</td></tr>
<tr><td>Buffer</td><td>Shader Resource View</td></tr>
<tr><td>ConstantBuffer</td><td>Constant Buffer View</td></tr>
<tr><td>Count</td><td></td></tr>
</table>
<br/>

<b>ShaderResourceAccessType : The type of a shader resource</b><br/><br/>
<table>
<tr><th colspan=2>ShaderResourceAccessType</th></tr>
<tr><td>UAV</td><td>Unordered Access View (Read/Write)</td></tr>
<tr><td>SRV</td><td>Shader Resource View</td></tr>
<tr><td>CBV</td><td>Constant Buffer View</td></tr>
<tr><td>CopySource</td><td>SRV copy source</td></tr>
<tr><td>CopyDest</td><td>SRV copy dest</td></tr>
<tr><td>Indirect</td><td>Used in Execute Indirect</td></tr>
<tr><td>RTScene</td><td>The scene for raytracing (acceleration structure)</td></tr>
<tr><td>VertexBuffer</td><td>Used as a vertex buffer</td></tr>
<tr><td>IndexBuffer</td><td>Used as an index buffer</td></tr>
<tr><td>RenderTarget</td><td>Used as a color buffer</td></tr>
<tr><td>DepthTarget</td><td>Used as a depth buffer</td></tr>
<tr><td>Barrier</td><td>Used by the barrier node</td></tr>
<tr><td>ShadingRate</td><td>Used as a shading rate image</td></tr>
<tr><td>Noop</td><td>Used by the reroute node</td></tr>
<tr><td>Count</td><td></td></tr>
</table>
<br/>

<b>TextureViewType : The type that a texture is actually viewed as, in a shader. A subset of DataFieldType.</b><br/><br/>
<table>
<tr><th colspan=2>TextureViewType</th></tr>
<tr><td>Int</td><td>int</td></tr>
<tr><td>Int4</td><td>int[4]</td></tr>
<tr><td>Uint</td><td>uint</td></tr>
<tr><td>Uint2</td><td>uint[2]</td></tr>
<tr><td>Uint4</td><td>uint[4]</td></tr>
<tr><td>Float</td><td>float</td></tr>
<tr><td>Float2</td><td>float[2]</td></tr>
<tr><td>Float3</td><td>float[3]</td></tr>
<tr><td>Float4</td><td>float[4]</td></tr>
<tr><td>Int_64</td><td>int64_t</td></tr>
<tr><td>Uint_64</td><td>uint64_t</td></tr>
</table>
<br/>

<b>SamplerFilter : The type of filter a sampler uses</b><br/><br/>
<table>
<tr><th colspan=2>SamplerFilter</th></tr>
<tr><td>MinMagMipPoint</td><td>Point</td></tr>
<tr><td>MinMagLinear_MipPoint</td><td>Bilinear</td></tr>
<tr><td>MinMagMipLinear</td><td>Trilinear</td></tr>
<tr><td>Count</td><td></td></tr>
</table>
<br/>

<b>SamplerAddressMode : The sampler address mode</b><br/><br/>
<table>
<tr><th colspan=2>SamplerAddressMode</th></tr>
<tr><td>Clamp</td><td>Clamp</td></tr>
<tr><td>Wrap</td><td>Wrap</td></tr>
<tr><td>Border</td><td>Border</td></tr>
<tr><td>Count</td><td></td></tr>
</table>
<br/>

<b>TextureDimensionType : The type of a texture</b><br/><br/>
<table>
<tr><th colspan=2>TextureDimensionType</th></tr>
<tr><td>Texture2D</td><td>Texture2D</td></tr>
<tr><td>Texture2DArray</td><td>Texture2DArray</td></tr>
<tr><td>Texture3D</td><td>Texture3D</td></tr>
<tr><td>TextureCube</td><td>TextureCube</td></tr>
<tr><td>Texture2DMS</td><td>Texture2DMS</td></tr>
</table>
<br/>

<b>ShaderType : The type of a shader resource</b><br/><br/>
<table>
<tr><th colspan=2>ShaderType</th></tr>
<tr><td>Compute</td><td>Compute shader</td></tr>
<tr><td>RTRayGen</td><td>Ray generation shader</td></tr>
<tr><td>RTClosestHit</td><td>Closest hit shader</td></tr>
<tr><td>RTAnyHit</td><td>Any hit shader</td></tr>
<tr><td>RTIntersection</td><td>Intersection shader</td></tr>
<tr><td>RTMiss</td><td>Miss shader</td></tr>
<tr><td>Vertex</td><td>Vertex shader</td></tr>
<tr><td>Pixel</td><td>Pixel shader</td></tr>
<tr><td>Amplification</td><td>Amplification shader</td></tr>
<tr><td>Mesh</td><td>Mesh shader</td></tr>
<tr><td>Count</td><td></td></tr>
</table>
<br/>

<b>ShaderLanguage : A shader source code language</b><br/><br/>
<table>
<tr><th colspan=2>ShaderLanguage</th></tr>
<tr><td>HLSL</td><td>The directx shader language. https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl</td></tr>
<tr><td>Slang</td><td>The slang shader language. https://shader-slang.org/</td></tr>
<tr><td>WGSL</td><td>The WebGPU shader language. https://www.w3.org/TR/WGSL/</td></tr>
</table>
<br/>

<b>StructFieldSemantic : Used to specify if the struct field has special meaning, such as a vertex position in a vertex buffer.</b><br/><br/>
<table>
<tr><th colspan=2>StructFieldSemantic</th></tr>
<tr><td>Position</td><td>float3</td></tr>
<tr><td>Color</td><td>float4</td></tr>
<tr><td>Normal</td><td>float3</td></tr>
<tr><td>Tangent</td><td>float4</td></tr>
<tr><td>UV</td><td>float2</td></tr>
<tr><td>MaterialID</td><td>int</td></tr>
<tr><td>ShapeID</td><td>int</td></tr>
<tr><td>Count</td><td></td></tr>
</table>
<br/>

<b>GigiSlangOptimizationLevel : The level of optimizations</b><br/><br/>
<table>
<tr><th colspan=2>GigiSlangOptimizationLevel</th></tr>
<tr><td>None</td><td>Don't optimize at all.</td></tr>
<tr><td>Default</td><td>Default optimization level: balance code quality and compilation time.</td></tr>
<tr><td>High</td><td>Optimize aggressively.</td></tr>
<tr><td>Maximum</td><td>Include optimizations that may take a very long time, or may involve severe space-vs-speed tradeoffs.</td></tr>
</table>
<br/>

<b>GigiSlangFloatingPointMode : Floating point mode</b><br/><br/>
<table>
<tr><th colspan=2>GigiSlangFloatingPointMode</th></tr>
<tr><td>Default</td><td></td></tr>
<tr><td>Fast</td><td></td></tr>
<tr><td>Precise</td><td></td></tr>
</table>
<br/>

<b>ResourceVisibility : </b><br/><br/>
<table>
<tr><th colspan=2>ResourceVisibility</th></tr>
<tr><td>Imported</td><td>Provided as input by the host application</td></tr>
<tr><td>Internal</td><td>Used internally to the technique only</td></tr>
<tr><td>Exported</td><td>Managed by the technique but visible to the host application</td></tr>
<tr><td>Count</td><td></td></tr>
</table>
<br/>

<b>DrawCullMode : </b><br/><br/>
<table>
<tr><th colspan=2>DrawCullMode</th></tr>
<tr><td>None</td><td></td></tr>
<tr><td>Front</td><td></td></tr>
<tr><td>Back</td><td></td></tr>
</table>
<br/>

<b>DepthTestFunction : </b><br/><br/>
<table>
<tr><th colspan=2>DepthTestFunction</th></tr>
<tr><td>Never</td><td></td></tr>
<tr><td>Less</td><td></td></tr>
<tr><td>Equal</td><td></td></tr>
<tr><td>LessEqual</td><td></td></tr>
<tr><td>Greater</td><td></td></tr>
<tr><td>NotEqual</td><td></td></tr>
<tr><td>GreaterEqual</td><td></td></tr>
<tr><td>Always</td><td></td></tr>
</table>
<br/>

<b>DrawBlendMode : </b><br/><br/>
<table>
<tr><th colspan=2>DrawBlendMode</th></tr>
<tr><td>Zero</td><td></td></tr>
<tr><td>One</td><td></td></tr>
<tr><td>SrcColor</td><td></td></tr>
<tr><td>InvSrcColor</td><td></td></tr>
<tr><td>SrcAlpha</td><td></td></tr>
<tr><td>InvSrcAlpha</td><td></td></tr>
<tr><td>DestAlpha</td><td></td></tr>
<tr><td>InvDestAlpha</td><td></td></tr>
<tr><td>DestColor</td><td></td></tr>
<tr><td>InvDestColor</td><td></td></tr>
</table>
<br/>

<b>StencilOp : </b><br/><br/>
<table>
<tr><th colspan=2>StencilOp</th></tr>
<tr><td>Keep</td><td></td></tr>
<tr><td>Zero</td><td></td></tr>
<tr><td>Replace</td><td></td></tr>
<tr><td>IncrementSaturate</td><td></td></tr>
<tr><td>DecrimentSaturate</td><td></td></tr>
<tr><td>Invert</td><td></td></tr>
<tr><td>Increment</td><td></td></tr>
<tr><td>Decriment</td><td></td></tr>
</table>
<br/>

<b>ShadingRate : Used by variable rate shading</b><br/><br/>
<table>
<tr><th colspan=2>ShadingRate</th></tr>
<tr><td>_1x1</td><td></td></tr>
<tr><td>_1x2</td><td></td></tr>
<tr><td>_2x1</td><td></td></tr>
<tr><td>_2x2</td><td></td></tr>
<tr><td>_2x4</td><td></td></tr>
<tr><td>_4x2</td><td></td></tr>
<tr><td>_4x4</td><td></td></tr>
</table>
<br/>

<b>ShadingRateCombiner : Used by variable rate shading</b><br/><br/>
<table>
<tr><th colspan=2>ShadingRateCombiner</th></tr>
<tr><td>PassThrough</td><td></td></tr>
<tr><td>Override</td><td></td></tr>
<tr><td>Min</td><td></td></tr>
<tr><td>Max</td><td></td></tr>
<tr><td>Sum</td><td></td></tr>
</table>
<br/>

<b>GeometryType : </b><br/><br/>
<table>
<tr><th colspan=2>GeometryType</th></tr>
<tr><td>TriangleList</td><td></td></tr>
<tr><td>LineList</td><td></td></tr>
<tr><td>PointList</td><td></td></tr>
</table>
<br/>

<b>MemoryUnitOfMeasurement : </b><br/><br/>
<table>
<tr><th colspan=2>MemoryUnitOfMeasurement</th></tr>
<tr><td>Items</td><td></td></tr>
<tr><td>Bytes</td><td></td></tr>
</table>
<br/>

<b>TextureFormat : </b><br/><br/>
<table>
<tr><th colspan=2>TextureFormat</th></tr>
<tr><td>Any</td><td>Only valid for imported textures.</td></tr>
<tr><td>R8_Unorm</td><td>R 8 bit unorm</td></tr>
<tr><td>RG8_Unorm</td><td>RG 8 bit unorm</td></tr>
<tr><td>RGBA8_Unorm</td><td>RGBA 8 bit unorm</td></tr>
<tr><td>RGBA8_Unorm_sRGB</td><td>RGBA 8 bit unorm, sRGB</td></tr>
<tr><td>BGRA8_Unorm</td><td>BGRA 8 bit unorm</td></tr>
<tr><td>R8_Snorm</td><td>R 8 bit snorm</td></tr>
<tr><td>RG8_Snorm</td><td>RG 8 bit snorm</td></tr>
<tr><td>RGBA8_Snorm</td><td>RGBA 8 bit snorm</td></tr>
<tr><td>R8_Uint</td><td>R 8 bit uint</td></tr>
<tr><td>RG8_Uint</td><td>RG 8 bit uint</td></tr>
<tr><td>RGBA8_Uint</td><td>RGBA 8 bit uint</td></tr>
<tr><td>R8_Sint</td><td>R 8 bit sint</td></tr>
<tr><td>RG8_Sint</td><td>RG 8 bit sint</td></tr>
<tr><td>RGBA8_Sint</td><td>RGBA 8 bit sint</td></tr>
<tr><td>R16_Float</td><td>R 16 bit float</td></tr>
<tr><td>RG16_Float</td><td>RG 16 bit float</td></tr>
<tr><td>RGBA16_Float</td><td>RGBA 16 bit float</td></tr>
<tr><td>RGBA16_Unorm</td><td>RGBA 16 bit unorm</td></tr>
<tr><td>RGBA16_Snorm</td><td>RGBA 16 bit snorm</td></tr>
<tr><td>RG16_Uint</td><td>RG 16 bit uint</td></tr>
<tr><td>R32_Float</td><td>R 32 bit float</td></tr>
<tr><td>RG32_Float</td><td>RG 32 bit float</td></tr>
<tr><td>RGBA32_Float</td><td>RGBA 32 bit float</td></tr>
<tr><td>R32_Uint</td><td>R 32 bit uint</td></tr>
<tr><td>RG32_Uint</td><td>RG 32 bit uint</td></tr>
<tr><td>RGBA32_Uint</td><td>RGBA 32 bit uint</td></tr>
<tr><td>R11G11B10_Float</td><td>RGB 32 bit (total) float</td></tr>
<tr><td>D32_Float</td><td>32 bit float depth</td></tr>
<tr><td>D16_Unorm</td><td>16 bit unorm depth</td></tr>
<tr><td>D32_Float_S8</td><td>32 bit depth, 8 bit stencil, and 24 more bits unused</td></tr>
<tr><td>D24_Unorm_S8</td><td>24 bit depth, 8 bit stencil</td></tr>
<tr><td>BC1_Unorm</td><td>RGB 5:6:5 unorm, 1 bit alpha. block compressed.</td></tr>
<tr><td>BC4_Unorm</td><td>R 8 bit unorm. block compressed.</td></tr>
<tr><td>BC4_Snorm</td><td>R 8 bit snorm. block compressed.</td></tr>
<tr><td>BC5_Unorm</td><td>RG 8 bit unorm. block compressed.</td></tr>
<tr><td>BC5_Snorm</td><td>RG 8 bit snorm. block compressed.</td></tr>
<tr><td>BC7_Unorm</td><td>RGB, alpha optional. block compressed.</td></tr>
<tr><td>BC7_Unorm_sRGB</td><td>RGB, alpha optional. sRGB. block compressed.</td></tr>
<tr><td>BC6_UF16</td><td>RGB, 16 bit float unsigned. block compressed.</td></tr>
<tr><td>BC6_SF16</td><td>RGB, 16 bit float signed. block compressed.</td></tr>
</table>
<br/>

<b>PreviewMsgCS_Log_Level : </b><br/><br/>
<table>
<tr><th colspan=2>PreviewMsgCS_Log_Level</th></tr>
<tr><td>Info</td><td></td></tr>
<tr><td>Warn</td><td></td></tr>
<tr><td>Error</td><td></td></tr>
</table>
<br/>

<b>GGUserFile_TLASBuildFlags : D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_PREFER_FAST_TRACE etc</b><br/><br/>
<table>
<tr><th colspan=2>GGUserFile_TLASBuildFlags</th></tr>
<tr><td>None</td><td></td></tr>
<tr><td>AllowUpdate</td><td></td></tr>
<tr><td>AllowCompaction</td><td></td></tr>
<tr><td>PreferFastTrace</td><td></td></tr>
<tr><td>PreferFastBuild</td><td></td></tr>
<tr><td>MinimizeMemory</td><td></td></tr>
</table>
<br/>

<b>GGUserFile_BLASCullMode : controls D3D12_RAYTRACING_INSTANCE_FLAG_TRIANGLE_CULL_DISABLE and D3D12_RAYTRACING_INSTANCE_FLAG_TRIANGLE_FRONT_COUNTERCLOCKWISE</b><br/><br/>
<table>
<tr><th colspan=2>GGUserFile_BLASCullMode</th></tr>
<tr><td>CullNone</td><td></td></tr>
<tr><td>FrontIsClockwise</td><td></td></tr>
<tr><td>FrontIsCounterClockwise</td><td></td></tr>
</table>
<br/>

<b>GGUserFile_CameraJitterType : The sequence of the jittered projection matrix</b><br/><br/>
<table>
<tr><th colspan=2>GGUserFile_CameraJitterType</th></tr>
<tr><td>None</td><td>No Jitter</td></tr>
<tr><td>UniformWhite</td><td>Uniform white noise</td></tr>
<tr><td>Halton23</td><td>Halton(2,3)</td></tr>
</table>
<br/>

<b>BackendTemplateFileType : </b><br/><br/>
<table>
<tr><th colspan=2>BackendTemplateFileType</th></tr>
<tr><td>Output</td><td>This goes into the output package</td></tr>
<tr><td>InternalShader</td><td>This is a shader used during the code gen process, but should not be part of the output package</td></tr>
</table>
<br/>

<b>GigiCompileResult : </b><br/><br/>
<table>
<tr><th colspan=2>GigiCompileResult</th></tr>
<tr><td>OK</td><td></td></tr>
<tr><td>WrongVersion</td><td></td></tr>
<tr><td>WrongParams</td><td></td></tr>
<tr><td>CantLoadRenderGraph</td><td></td></tr>
<tr><td>ShaderAsserts</td><td></td></tr>
<tr><td>ShaderReflection</td><td></td></tr>
<tr><td>Validation</td><td></td></tr>
<tr><td>ReferenceFixup</td><td></td></tr>
<tr><td>DepluralizeFileCopies</td><td></td></tr>
<tr><td>NoBackend</td><td></td></tr>
<tr><td>BackendData</td><td></td></tr>
<tr><td>Sanitize</td><td></td></tr>
<tr><td>NotCompiledYet</td><td></td></tr>
<tr><td>InterpreterError</td><td></td></tr>
<tr><td>InlineSubGraphs</td><td></td></tr>
<tr><td>ErrorCheck</td><td></td></tr>
<tr><td>ShaderFileDuplication</td><td></td></tr>
<tr><td>AddNodeInfoToShaders</td><td></td></tr>
<tr><td>DataFixup</td><td></td></tr>
<tr><td>DfltFixup</td><td></td></tr>
<tr><td>HandleOutputsToMultiInput</td><td></td></tr>
<tr><td>DuplicateNodeShaders</td><td></td></tr>
</table>
<br/>

<b>GigiCompileWarning : Gigi compilation warnings</b><br/><br/>
<table>
<tr><th colspan=2>GigiCompileWarning</th></tr>
<tr><td>ShaderUnusedResource</td><td>A declared resource does not appear to be used in a shader. This can lead to additional transitions and unnecessary ordering constraints.</td></tr>
<tr><td>Count</td><td></td></tr>
</table>
<br/>

<b>DXShaderCompiler : Which directx shader compiler to use</b><br/><br/>
<table>
<tr><th colspan=2>DXShaderCompiler</th></tr>
<tr><td>FXC</td><td>The old shader compilation path.</td></tr>
<tr><td>DXC</td><td>The newer shader compilation path, required for raytracing.</td></tr>
</table>
<br/>

<b>FileCopyType : </b><br/><br/>
<table>
<tr><th colspan=2>FileCopyType</th></tr>
<tr><td>Private</td><td>Provided as input by the host application</td></tr>
<tr><td>Shader</td><td>Used internally to the technique only</td></tr>
<tr><td>Asset</td><td>An asset used by the technique</td></tr>
<tr><td>Count</td><td></td></tr>
</table>
<br/>

<b>SetVariableOperator : </b><br/><br/>
<table>
<tr><th colspan=2>SetVariableOperator</th></tr>
<tr><td>Add</td><td>+</td></tr>
<tr><td>Subtract</td><td>-</td></tr>
<tr><td>Multiply</td><td>*</td></tr>
<tr><td>Divide</td><td>/</td></tr>
<tr><td>Modulo</td><td>%</td></tr>
<tr><td>PowerOf2GE</td><td>The next power of two, greater or equal to the current value</td></tr>
<tr><td>Minimum</td><td>min(A,B)</td></tr>
<tr><td>Maximum</td><td>max(A,B)</td></tr>
<tr><td>BitwiseOr</td><td>A | B</td></tr>
<tr><td>BitwiseAnd</td><td>A & B</td></tr>
<tr><td>BitwiseXor</td><td>A ^ B</td></tr>
<tr><td>BitwiseNot</td><td>~A</td></tr>
<tr><td>Noop</td><td>Dont do anything, returns the left value. Useful for assignment. This does implicit type casting.</td></tr>
</table>
<br/>

<h1>Structs</h1>
Italicized fields are not serialized, and are just used for runtime storage.<br/>
<br/>
<b>BackendRestriction : Allows restriction to specific backends</b><br/><br/>
<table>
<tr><th colspan=3>BackendRestriction</th></tr>
<tr><td>Backend backends[]</td><td></td><td>A list of backends supported. Empty list means all backends</td></tr>
<tr><td>bool isWhiteList</td><td>true</td><td>If true, this is a list of allowed platforms. if false, it's a list of disallowed platforms.</td></tr>
<tr><td><i>unsigned int backendFlags</i></td><td>0</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>VariableReference : A reference to a variable</b><br/><br/>
<table>
<tr><th colspan=3>VariableReference</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the variable.</td></tr>
<tr><td><i>int variableIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>DataFieldType UIType</i></td><td>DataFieldType::Count</td><td>If not count, will limit to variables of the specific type.</td></tr>
</table>
<br/>

<b>VariableReferenceNoConst : A reference to a variable. No const variables allowed.</b><br/><br/>
<table>
<tr><th colspan=3>VariableReferenceNoConst</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the variable.</td></tr>
<tr><td><i>int variableIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>VariableReferenceConstOnly : A reference to a variable. Only const variables allowed.</b><br/><br/>
<table>
<tr><th colspan=3>VariableReferenceConstOnly</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the variable.</td></tr>
<tr><td><i>int variableIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>VariableUISettings : UI information for variables</b><br/><br/>
<table>
<tr><th colspan=3>VariableUISettings</th></tr>
<tr><td>VariableUIHint UIHint</td><td>VariableUIHint::Count</td><td>Any hints for UI</td></tr>
<tr><td>std::string min</td><td>""</td><td>The minimum value of the variable. Leave blank for no minimum.</td></tr>
<tr><td>std::string max</td><td>""</td><td>The maximum value of the variable. Leave blank for no maximum.</td></tr>
<tr><td>std::string step</td><td>""</td><td>The step size of the variable. Leave blank for default step size.</td></tr>
</table>
<br/>

<b>Variable : A variable definition</b><br/><br/>
<table>
<tr><th colspan=3>Variable</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the variable.</td></tr>
<tr><td>std::string comment</td><td>""</td><td>A comment for the variable.</td></tr>
<tr><td>DataFieldType type</td><td>DataFieldType::Count</td><td>The type of the variable</td></tr>
<tr><td>bool Const</td><td>false</td><td>If true, the variable is declared const and cannot change at runtime</td></tr>
<tr><td>bool Static</td><td>false</td><td>If true, the variable has the same value for all instances of the technique</td></tr>
<tr><td>std::string dflt</td><td>""</td><td>The default value of the variable. The default memory is zero initialized before this is parsed, so if you don't give it enough initializers, it will use zero for the unlisted fields.</td></tr>
<tr><td>VariableVisibility visibility</td><td>VariableVisibility::Internal</td><td>Who can see and interact with this variable</td></tr>
<tr><td>std::string Enum</td><td>""</td><td>Integer types can specify an enum, which will then make symbols in both C++ and shader code.</td></tr>
<tr><td>VariableReference onUserChange</td><td>{}</td><td>A boolean variable that gets set to true when the user changes this variable.</td></tr>
<tr><td>BackendRestriction backends</td><td>{}</td><td>This variable can be limited to specific backends</td></tr>
<tr><td>bool transient</td><td>false</td><td>If true, the variable should not be saved between runs of this technique. The Gigi viewer uses this to decide if it should save it in the gguser file or not, for example.</td></tr>
<tr><td>VariableUISettings UISettings</td><td>{}</td><td>UI Settings.</td></tr>
<tr><td>std::string UIGroup</td><td>""</td><td>Used to organize variables into folders in the viewer. separate folders with dots.  For instance: settings.controls</td></tr>
<tr><td><i>int enumIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>std::string originalName</i></td><td>""</td><td>The name before renames and sanitization</td></tr>
<tr><td><i>std::string scope</i></td><td>""</td><td>The scope that the node lives in. A possibly nested list of subgraph node names, seperated by a dot.</td></tr>
<tr><td><i>bool system</i></td><td>false</td><td>Is set if the runtime overrides the value</td></tr>
<tr><td>VariableUIHint UIHint</td><td>VariableUIHint::Count</td><td>Any hints for UI</td></tr>
</table>
<br/>

<b>Condition : Specifiy a condition to make something conditional</b><br/><br/>
<table>
<tr><th colspan=3>Condition</th></tr>
<tr><td>std::string variable1</td><td>{}</td><td>Value 1</td></tr>
<tr><td>ConditionComparison comparison</td><td>ConditionComparison::Count</td><td>The comparison operator</td></tr>
<tr><td>std::string value2</td><td>{}</td><td>Value 2</td></tr>
<tr><td>std::string variable2</td><td>{}</td><td>Value 2</td></tr>
<tr><td><i>int variable1Index</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>int variable2Index</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td>bool alwaysFalse</td><td>false</td><td>If checked, condition always evaluates to false</td></tr>
<tr><td><i>bool hideUI</i></td><td>false</td><td>Used by editor to hide this UI when it isn't supported</td></tr>
</table>
<br/>

<b>EnumItem : Specifiy an enum</b><br/><br/>
<table>
<tr><th colspan=3>EnumItem</th></tr>
<tr><td>std::string label</td><td>""</td><td>The text label of an enum</td></tr>
<tr><td><i>std::string displayLabel</i></td><td>""</td><td>name before sanitization</td></tr>
<tr><td>std::string comment</td><td>""</td><td></td></tr>
</table>
<br/>

<b>Enum : Specifiy an enum</b><br/><br/>
<table>
<tr><th colspan=3>Enum</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the enum</td></tr>
<tr><td>EnumItem items[]</td><td></td><td>The items in the enum. Values start at 0 and count up from there.</td></tr>
<tr><td>std::string comment</td><td>""</td><td></td></tr>
<tr><td><i>std::string originalName</i></td><td>""</td><td>The name before renames and sanitization</td></tr>
<tr><td><i>std::string scope</i></td><td>""</td><td>The scope that the node lives in. A possibly nested list of subgraph node names, seperated by a dot.</td></tr>
</table>
<br/>

<b>CooperativeVectorData : Data needed for cooperative vectors support for imported buffer resources</b><br/><br/>
<table>
<tr><th colspan=3>CooperativeVectorData</th></tr>
<tr><td>bool convert</td><td>false</td><td>If true, does the data conversion described below</td></tr>
<tr><td>unsigned int width</td><td>1</td><td>How many columns in the matrix or vector.</td></tr>
<tr><td>unsigned int height</td><td>1</td><td>How many rows in the matrix or vector.</td></tr>
<tr><td>CooperativeVectorDataType srcType</td><td>CooperativeVectorDataType::_float32</td><td>The data type of the source data.</td></tr>
<tr><td>CooperativeVectorBufferLayout srcLayout</td><td>CooperativeVectorBufferLayout::RowMajor</td><td>The layout of the source data.</td></tr>
<tr><td>CooperativeVectorDataType destType</td><td>CooperativeVectorDataType::_float16</td><td>The data type you want it to be converted to.</td></tr>
<tr><td>CooperativeVectorBufferLayout destLayout</td><td>CooperativeVectorBufferLayout::RowMajor</td><td>The layout you want it to be converted to.</td></tr>
</table>
<br/>

<b>StructReference : A reference to a struct</b><br/><br/>
<table>
<tr><th colspan=3>StructReference</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the struct.</td></tr>
<tr><td><i>int structIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>ComputeShaderReference : A reference to a shader</b><br/><br/>
<table>
<tr><th colspan=3>ComputeShaderReference</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader</td></tr>
<tr><td><i>int shaderIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>struct Shader* shader</i></td><td>nullptr</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>RayGenShaderReference : A reference to a ray gen shader</b><br/><br/>
<table>
<tr><th colspan=3>RayGenShaderReference</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader</td></tr>
<tr><td><i>int shaderIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>struct Shader* shader</i></td><td>nullptr</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>RTClosestHitShaderReference : A reference to a RTClosestHit shader</b><br/><br/>
<table>
<tr><th colspan=3>RTClosestHitShaderReference</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader</td></tr>
<tr><td><i>int shaderIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>struct Shader* shader</i></td><td>nullptr</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>RTClosestHitShaderReferenceOptional : Optional version</b><br/><br/>
<table>
<tr><th colspan=3>RTClosestHitShaderReferenceOptional</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader</td></tr>
<tr><td><i>int shaderIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>struct Shader* shader</i></td><td>nullptr</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>RTAnyHitShaderReference : A reference to RTAnyHit shader</b><br/><br/>
<table>
<tr><th colspan=3>RTAnyHitShaderReference</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader</td></tr>
<tr><td><i>int shaderIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>struct Shader* shader</i></td><td>nullptr</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>RTAnyHitShaderReferenceOptional : Optional version</b><br/><br/>
<table>
<tr><th colspan=3>RTAnyHitShaderReferenceOptional</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader</td></tr>
<tr><td><i>int shaderIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>struct Shader* shader</i></td><td>nullptr</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>RTIntersectionShaderReference : A reference to an RTIntersection shader</b><br/><br/>
<table>
<tr><th colspan=3>RTIntersectionShaderReference</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader</td></tr>
<tr><td><i>int shaderIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>struct Shader* shader</i></td><td>nullptr</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>RTIntersectionShaderReferenceOptional : Optional version</b><br/><br/>
<table>
<tr><th colspan=3>RTIntersectionShaderReferenceOptional</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader</td></tr>
<tr><td><i>int shaderIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>struct Shader* shader</i></td><td>nullptr</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>VertexShaderReference : A reference to a vertex shader</b><br/><br/>
<table>
<tr><th colspan=3>VertexShaderReference</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader</td></tr>
<tr><td><i>int shaderIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>struct Shader* shader</i></td><td>nullptr</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>PixelShaderReference : A reference to a pixel shader</b><br/><br/>
<table>
<tr><th colspan=3>PixelShaderReference</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader</td></tr>
<tr><td><i>int shaderIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>struct Shader* shader</i></td><td>nullptr</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>AmplificationShaderReference : A reference to an amplification shader</b><br/><br/>
<table>
<tr><th colspan=3>AmplificationShaderReference</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader</td></tr>
<tr><td><i>int shaderIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>struct Shader* shader</i></td><td>nullptr</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>MeshShaderReference : A reference to a mesh shader</b><br/><br/>
<table>
<tr><th colspan=3>MeshShaderReference</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader</td></tr>
<tr><td><i>int shaderIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>struct Shader* shader</i></td><td>nullptr</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>VertexShaderReferenceOptional : An optional reference to a vertex shader</b><br/><br/>
<table>
<tr><th colspan=3>VertexShaderReferenceOptional</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader</td></tr>
<tr><td><i>int shaderIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>struct Shader* shader</i></td><td>nullptr</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>PixelShaderReferenceOptional : An optional reference to a pixel shader</b><br/><br/>
<table>
<tr><th colspan=3>PixelShaderReferenceOptional</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader</td></tr>
<tr><td><i>int shaderIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>struct Shader* shader</i></td><td>nullptr</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>AmplificationShaderReferenceOptional : An optional reference to an amplification shader</b><br/><br/>
<table>
<tr><th colspan=3>AmplificationShaderReferenceOptional</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader</td></tr>
<tr><td><i>int shaderIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>struct Shader* shader</i></td><td>nullptr</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>MeshShaderReferenceOptional : An optional reference to a mesh shader</b><br/><br/>
<table>
<tr><th colspan=3>MeshShaderReferenceOptional</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader</td></tr>
<tr><td><i>int shaderIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>struct Shader* shader</i></td><td>nullptr</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>StructField : A field in a struct</b><br/><br/>
<table>
<tr><th colspan=3>StructField</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the field</td></tr>
<tr><td>DataFieldType type</td><td>DataFieldType::Count</td><td>The type of the field</td></tr>
<tr><td>std::string dflt</td><td>""</td><td>The default value</td></tr>
<tr><td>std::string comment</td><td>""</td><td>A comment to explain the field</td></tr>
<tr><td>std::string Enum</td><td>""</td><td>Integer types can specify an enum, which will then make symbols in both C++ and shader code.</td></tr>
<tr><td>StructFieldSemantic semantic</td><td>StructFieldSemantic::Count</td><td>Used to specify if the struct field has special meaning, such as a vertex position in a vertex buffer. If none is given, it shows up in shaders as an autonumbering text coordinate.</td></tr>
<tr><td>int semanticIndex</td><td>0</td><td>Some semantics can have multiple channels, like UVs and colors</td></tr>
<tr><td>bool allowAtomicOps</td><td>false</td><td>Nedeed by WebGPU. Check this box to allow atopic operations on this field.</td></tr>
<tr><td><i>bool isPadding</i></td><td>false</td><td>true if this field was added to pad the struct for alignment reasons.</td></tr>
<tr><td><i>int enumIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>size_t sizeInBytes</i></td><td>0</td><td>The size in bytes of this field</td></tr>
</table>
<br/>

<b>Struct : A description of a struct</b><br/><br/>
<table>
<tr><th colspan=3>Struct</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the struct.</td></tr>
<tr><td>bool forceHostVisible</td><td>false</td><td>If true, the struct will be visible to the host, even if the struct isn't used by anything host visible.</td></tr>
<tr><td>StructField fields[]</td><td></td><td>The data fields</td></tr>
<tr><td><i>size_t sizeInBytes</i></td><td>0</td><td>The size in bytes of this struct</td></tr>
<tr><td><i>bool exported</i></td><td>false</td><td>If true, will be visible to the host app</td></tr>
<tr><td>std::string definition</td><td>""</td><td>The parsed string definition of the struct.</td></tr>
<tr><td><i>std::string originalName</i></td><td>""</td><td>The name before renames and sanitization</td></tr>
<tr><td><i>std::string scope</i></td><td>""</td><td>The scope that the node lives in. A possibly nested list of subgraph node names, seperated by a dot.</td></tr>
<tr><td><i>bool isForShaderConstants</i></td><td>false</td><td>If true, this struct is used by shader constants, else it isn't</td></tr>
</table>
<br/>

<b>ShaderResourceBuffer : Data specific to buffers</b><br/><br/>
<table>
<tr><th colspan=3>ShaderResourceBuffer</th></tr>
<tr><td>DataFieldType type</td><td>DataFieldType::Count</td><td>The data type of the buffer if a simple type</td></tr>
<tr><td>StructReference typeStruct</td><td>{}</td><td>The data type of the buffer if a struct type</td></tr>
<tr><td>bool raw</td><td>false</td><td>If true, will be viewed raw in the shader (E.g. DX12 ByteAddressBuffer)</td></tr>
<tr><td>bool PODAsStructuredBuffer</td><td>true</td><td>Set this to true if you want it to be StructuredBuffer instead of a Buffer, for non structure typed buffers.</td></tr>
<tr><td>bool globallyCoherent</td><td>false</td><td>Set this to true if you want the resource to be declared as globallycoherent.</td></tr>
<tr><td><i>bool hideUI</i></td><td>false</td><td>the shader resource will change this flag based on the type of the resource chosen</td></tr>
</table>
<br/>

<b>ShaderResourceTexture : Data specific to textures</b><br/><br/>
<table>
<tr><th colspan=3>ShaderResourceTexture</th></tr>
<tr><td>TextureDimensionType dimension</td><td>TextureDimensionType::Texture2D</td><td>The dimensionality of the texture</td></tr>
<tr><td>TextureViewType viewType</td><td>TextureViewType::Float4</td><td>The dimensionality of the texture</td></tr>
<tr><td>bool globallyCoherent</td><td>false</td><td>Set this to true if you want the resource to be declared as globallycoherent.</td></tr>
<tr><td><i>bool hideUI</i></td><td>false</td><td>the shader resource will change this flag based on the type of the resource chosen</td></tr>
</table>
<br/>

<b>ShaderSampler : Data specific to samplers</b><br/><br/>
<table>
<tr><th colspan=3>ShaderSampler</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the resource in the shader</td></tr>
<tr><td>SamplerFilter filter</td><td>SamplerFilter::MinMagMipLinear</td><td>The type of filtering to do</td></tr>
<tr><td>SamplerAddressMode addressMode</td><td>SamplerAddressMode::Wrap</td><td>The sampling address mode</td></tr>
<tr><td><i>int registerIndex</i></td><td>-1</td><td>For root signatures and shader code that wants registers declared. Calculated before backend code is called, for convenience of backends.</td></tr>
<tr><td><i>std::string registerSpaceString</i></td><td>""</td><td>Displayed after the register in the shader</td></tr>
</table>
<br/>

<b>ShaderResource : A declaration of a resource that a shader wants</b><br/><br/>
<table>
<tr><th colspan=3>ShaderResource</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the resource in the shader</td></tr>
<tr><td>ShaderResourceAccessType access</td><td>ShaderResourceAccessType::Count</td><td>How the resource is accessed</td></tr>
<tr><td>ShaderResourceType type</td><td>ShaderResourceType::Count</td><td>The resource type</td></tr>
<tr><td>ShaderResourceBuffer buffer</td><td>{}</td><td>Data specific to buffers</td></tr>
<tr><td>ShaderResourceTexture texture</td><td>{}</td><td>Data specific to textures</td></tr>
<tr><td>BackendRestriction backends</td><td>{}</td><td>The backends this resource is present for.</td></tr>
<tr><td>bool allowAtomicOps</td><td>false</td><td>Nedeed by WebGPU. Check this box to allow atopic operations on this field.</td></tr>
<tr><td><i>int registerIndex</i></td><td>-1</td><td>For root signatures and shader code that wants registers declared. Calculated before backend code is called, for convenience of backends.</td></tr>
<tr><td><i>std::string registerSpaceString</i></td><td>""</td><td>Displayed after the register in the shader</td></tr>
<tr><td><i>int constantBufferStructIndex</i></td><td>-1</td><td>for CBVs, this is the index in renderGraph.structs that describes the constant buffer</td></tr>
<tr><td><i>ShaderResourceAccessType originalAccess</i></td><td>ShaderResourceAccessType::Count</td><td>If the access is changed (like in post load), this is what it was originally. If this is Count, it wasn't changed.</td></tr>
</table>
<br/>

<b>ShaderConstantBuffer : A reference to a struct</b><br/><br/>
<table>
<tr><th colspan=3>ShaderConstantBuffer</th></tr>
<tr><td>std::string resourceName</td><td>""</td><td>The name of the resource in the shader</td></tr>
<tr><td>std::string structName</td><td>""</td><td>The name of the struct used</td></tr>
<tr><td><i>int structIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>ShaderDefine : A shader define as part of shader compilation</b><br/><br/>
<table>
<tr><th colspan=3>ShaderDefine</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the define.</td></tr>
<tr><td>std::string value</td><td>""</td><td>The value of the define.</td></tr>
</table>
<br/>

<b>TokenReplacement : A shader token replacement</b><br/><br/>
<table>
<tr><th colspan=3>TokenReplacement</th></tr>
<tr><td>std::string name</td><td>""</td><td>The token string.</td></tr>
<tr><td>std::string value</td><td>""</td><td>The replacement.</td></tr>
</table>
<br/>

<b>LoadedTextureReference : Information about a loaded texture referenced by this shader.</b><br/><br/>
<table>
<tr><th colspan=3>LoadedTextureReference</th></tr>
<tr><td>std::string token</td><td>""</td><td>The token as it appears in the shader.</td></tr>
<tr><td>std::string resourceName</td><td>""</td><td>The name of the resource to replace it with.</td></tr>
</table>
<br/>

<b>ShaderVariableAliasDeclaration : Specify a variable alias</b><br/><br/>
<table>
<tr><th colspan=3>ShaderVariableAliasDeclaration</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the alias. The name used in the /*$(VariableAlias:name)*/ tag in the shader.</td></tr>
<tr><td>DataFieldType type</td><td>DataFieldType::Count</td><td>The type of the alias.</td></tr>
<tr><td><i>bool usedInShader</i></td><td>false</td><td>set to true if this is actually used in the shader</td></tr>
</table>
<br/>

<b>RTHitGroup : A declaration of a ray tracing hit group, which may contain a closest hit, any hit, and intersection shader</b><br/><br/>
<table>
<tr><th colspan=3>RTHitGroup</th></tr>
<tr><td>std::string name</td><td>""</td><td>The unique name of the hit group</td></tr>
<tr><td>RTClosestHitShaderReferenceOptional closestHit</td><td>{}</td><td>The closest hit shader</td></tr>
<tr><td>RTAnyHitShaderReferenceOptional anyHit</td><td>{}</td><td>The any hit shader</td></tr>
<tr><td>RTIntersectionShaderReferenceOptional intersection</td><td>{}</td><td>The intersection shader</td></tr>
<tr><td><i>std::string originalName</i></td><td>""</td><td>The name before renames and sanitization</td></tr>
<tr><td><i>std::string scope</i></td><td>""</td><td>The scope that the node lives in. A possibly nested list of subgraph node names, seperated by a dot.</td></tr>
</table>
<br/>

<b>SlangOptions : Slang options</b><br/><br/>
<table>
<tr><th colspan=3>SlangOptions</th></tr>
<tr><td>bool noNameMangling</td><td>false</td><td>Do as little mangling of names as possible, to try to preserve original names.</td></tr>
<tr><td>bool lineDirectives</td><td>true</td><td>Whether to output line directives in the shader.</td></tr>
<tr><td>bool warningsAsErrors</td><td>false</td><td>Warnings are errors.</td></tr>
<tr><td>bool verbosePaths</td><td>false</td><td>Verbose Paths.</td></tr>
<tr><td>GigiSlangFloatingPointMode floatingPointMode</td><td>GigiSlangFloatingPointMode::Default</td><td>Floating point mode</td></tr>
<tr><td>GigiSlangOptimizationLevel optimizationLevel</td><td>GigiSlangOptimizationLevel::Default</td><td>Optimization level</td></tr>
<tr><td>bool process</td><td>false</td><td>if true, this shader will be processed by slang</td></tr>
</table>
<br/>

<b>Shader : A declaration of a shader</b><br/><br/>
<table>
<tr><th colspan=3>Shader</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader, as it will be referenced by nodes</td></tr>
<tr><td>std::string fileName</td><td>""</td><td>The file name of the shader file.</td></tr>
<tr><td><i>std::string destFileName</i></td><td>""</td><td>Filled out by compiler.  Where the shader file is supposed to go after compilation.</td></tr>
<tr><td>ShaderLanguage language</td><td>ShaderLanguage::HLSL</td><td>What language the shader is written in</td></tr>
<tr><td>ShaderType type</td><td>ShaderType::Compute</td><td>The type of shader it is</td></tr>
<tr><td>std::string entryPoint</td><td>"main"</td><td>The shader entrypoint.</td></tr>
<tr><td>ShaderDefine defines[]</td><td></td><td>The defines the shader is compiled with.</td></tr>
<tr><td><i>TokenReplacement tokenReplacements[]</i></td><td></td><td>The token replacements specific for the shader.</td></tr>
<tr><td>int NumThreads[3]</td><td>{ 8 , 8 , 1 }</td><td>The number of threads each dispatch has, for applicable shader types. 64,1,1 suggested for 1d. 8,8,1 for 2d. 4,4,4 for 3d.</td></tr>
<tr><td>bool copyFile</td><td>true</td><td>if false, will not copy the file over. A hackaround for when you have multiple raytracing shaders in the same file. TODO: resolve this better.</td></tr>
<tr><td>SlangOptions slangOptions</td><td>{}</td><td>Settings for optionally processing shaders with slang</td></tr>
<tr><td>BackendRestriction backends</td><td>{}</td><td>The backends this file copy happens for.</td></tr>
<tr><td>ShaderResource resources[]</td><td></td><td>SRVs, UAVs etc. that the shader wants to access. Generates code into the shader for their declarations.</td></tr>
<tr><td>ShaderSampler samplers[]</td><td></td><td>SRVs, UAVs etc. that the shader wants to access. Generates code into the shader for their declarations.</td></tr>
<tr><td>ShaderVariableAliasDeclaration variableAliases[]</td><td></td><td>Variable aliases allow a shader to read different variables per node by choosing what variable value is set for each alias</td></tr>
<tr><td>ShaderConstantBuffer constantBuffers[]</td><td></td><td>A list of constant buffers this shader wants.</td></tr>
<tr><td><i>std::vector<LoadedTextureReference> loadedTextureRefs</i></td><td>{}</td><td>The list of loaded textures this shader references.</td></tr>
<tr><td><i>std::wstring entryPointW</i></td><td>L""</td><td>The wide string version of the entry point. Made for convinience.</td></tr>
<tr><td><i>std::string originalName</i></td><td>""</td><td>The name before renames and sanitization</td></tr>
<tr><td><i>std::string scope</i></td><td>""</td><td>The scope that the node lives in. A possibly nested list of subgraph node names, seperated by a dot.</td></tr>
<tr><td><i>std::string Used_RTHitGroupIndex[]</i></td><td></td><td>All RTHitGroupIndex names used in the shader</td></tr>
<tr><td><i>std::string Used_RTMissIndex[]</i></td><td></td><td>All RTMissIndex names used in the shader</td></tr>
<tr><td>int CSNumThreads[3]</td><td>{ 8 , 8 , 1 }</td><td>For compute shaders only, the number of threads each dispatch has. 64,1,1 suggested for 1d. 8,8,1 for 2d. 4,4,4 for 3d.</td></tr>
</table>
<br/>

<b>NodeReference : A generic node reference</b><br/><br/>
<table>
<tr><th colspan=3>NodeReference</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the node</td></tr>
<tr><td><i>int nodeIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>TextureNodeReference : A texture node reference</b><br/><br/>
<table>
<tr><th colspan=3>TextureNodeReference - Inherits from NodeReference</th></tr>
<tr><td><i>struct RenderGraphNode_Resource_Texture* textureNode</i></td><td>nullptr</td><td>A pointer to the texture node</td></tr>
</table>
<br/>

<b>BufferNodeReference : A buffer node reference</b><br/><br/>
<table>
<tr><th colspan=3>BufferNodeReference - Inherits from NodeReference</th></tr>
<tr><td><i>struct RenderGraphNode_Resource_Buffer* bufferNode</i></td><td>nullptr</td><td>A pointer to the buffer node</td></tr>
</table>
<br/>

<b>TextureOrBufferNodeReference : A texture or buffer node reference</b><br/><br/>
<table>
<tr><th colspan=3>TextureOrBufferNodeReference - Inherits from NodeReference</th></tr>
<tr><td><i>struct RenderGraphNode_Resource_Texture* textureNode</i></td><td>nullptr</td><td>A pointer to the texture node</td></tr>
<tr><td><i>struct RenderGraphNode_Resource_Buffer* bufferNode</i></td><td>nullptr</td><td>A pointer to the texture node</td></tr>
</table>
<br/>

<b>NodePinReference : A reference to a pin on a node</b><br/><br/>
<table>
<tr><th colspan=3>NodePinReference</th></tr>
<tr><td>std::string node</td><td>""</td><td>The name of the node</td></tr>
<tr><td>std::string pin</td><td>""</td><td>The name of the pin</td></tr>
<tr><td><i>int nodeIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>int nodePinIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>int resourceNodeIndex</i></td><td>-1</td><td>Calculated for convenience. The resource node ultimately plugged into this pin.</td></tr>
</table>
<br/>

<b>NodePinReferenceOptional : A reference to a pin on a node</b><br/><br/>
<table>
<tr><th colspan=3>NodePinReferenceOptional</th></tr>
<tr><td>std::string node</td><td>""</td><td>The name of the node</td></tr>
<tr><td>std::string pin</td><td>""</td><td>The name of the pin</td></tr>
<tr><td><i>int nodeIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>int nodePinIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>int resourceNodeIndex</i></td><td>-1</td><td>Calculated for convenience. The resource node ultimately plugged into this pin.</td></tr>
</table>
<br/>

<b>NodePinConnection : A connection from a node to another node</b><br/><br/>
<table>
<tr><th colspan=3>NodePinConnection</th></tr>
<tr><td>std::string srcPin</td><td>""</td><td>The name of this pin</td></tr>
<tr><td>std::string dstNode</td><td>""</td><td>The name of the node</td></tr>
<tr><td>std::string dstPin</td><td>""</td><td>The name of the pin</td></tr>
<tr><td>BackendRestriction backends</td><td>{}</td><td>The backends this connection is present for.</td></tr>
<tr><td><i>int srcNodePinIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>int dstNodeIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>int dstNodePinIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>TextureSizeDesc : size = (inputSize + preAdd) * multiply / divide + postAdd.  inputSize is (1,1,1) if nothing given.</b><br/><br/>
<table>
<tr><th colspan=3>TextureSizeDesc</th></tr>
<tr><td>TextureNodeReference node</td><td>{}</td><td>If a texture is specified, the size will be based on the size of the texture. Padded with 1s to make it 3 dimensional.</td></tr>
<tr><td>VariableReference variable</td><td>{}</td><td>If a variable is given, the dispatch size will be based on the value of the variable. Padded with 1s to make it 3 dimensional.</td></tr>
<tr><td>int multiply[3]</td><td>{ 1 , 1 , 1 }</td><td></td></tr>
<tr><td>int divide[3]</td><td>{ 1 , 1 , 1 }</td><td></td></tr>
<tr><td>int preAdd[3]</td><td>{ 0 , 0 , 0 }</td><td></td></tr>
<tr><td>int postAdd[3]</td><td>{ 0 , 0 , 0 }</td><td></td></tr>
</table>
<br/>

<b>DispatchSizeDesc : The number of threads to dispatch. Not thread groups.  size = (inputSize + preAdd) * multiply / divide + postAdd.  inputSize is (1,1,1) if nothing given.</b><br/><br/>
<table>
<tr><th colspan=3>DispatchSizeDesc</th></tr>
<tr><td>TextureOrBufferNodeReference node</td><td>{}</td><td>If a texture or buffer is specified, the dispatch size will be based on the size of the texture or buffer. Padded with 1s to make it 3 dimensional.</td></tr>
<tr><td>VariableReference variable</td><td>{}</td><td>If a variable is given, the dispatch size will be based on the value of the variable. Padded with 1s to make it 3 dimensional.</td></tr>
<tr><td>NodePinReferenceOptional indirectBuffer</td><td>{}</td><td>If given, this buffer will be used as an indirect dispatch buffer</td></tr>
<tr><td>int multiply[3]</td><td>{ 1 , 1 , 1 }</td><td></td></tr>
<tr><td>int divide[3]</td><td>{ 1 , 1 , 1 }</td><td></td></tr>
<tr><td>int preAdd[3]</td><td>{ 0 , 0 , 0 }</td><td></td></tr>
<tr><td>int postAdd[3]</td><td>{ 0 , 0 , 0 }</td><td></td></tr>
<tr><td>VariableReference indirectOffsetVariable</td><td>{}</td><td>If a variable is given, it will be used as the offset into the indirect dispatch buffer. 0 would be the start of the buffer, 1 would start at the 4th value in the buffer, and so on.</td></tr>
<tr><td>int indirectOffsetValue</td><td>0</td><td>The offset into the indirect dispatch buffer if no variable given.  0 would be the start of the buffer, 1 would start at the 4th value in the buffer, and so on.</td></tr>
<tr><td><i>int shaderNumThreads[3]</i></td><td>{ 0 , 0 , 0 }</td><td></td></tr>
</table>
<br/>

<b>RayDispatchSizeDesc : size = (inputSize + preAdd) * multiply / divide + postAdd.  inputSize is (1,1,1) if nothing given.</b><br/><br/>
<table>
<tr><th colspan=3>RayDispatchSizeDesc</th></tr>
<tr><td>TextureOrBufferNodeReference node</td><td>{}</td><td>If a texture or buffer is specified, the dispatch size will be based on the size of the texture or buffer Padded with 1s to make it 3 dimensional.</td></tr>
<tr><td>VariableReference variable</td><td>{}</td><td>If a variable is given, the dispatch size will be based on the value of the variable. Padded with 1s to make it 3 dimensional.</td></tr>
<tr><td>int multiply[3]</td><td>{ 1 , 1 , 1 }</td><td></td></tr>
<tr><td>int divide[3]</td><td>{ 1 , 1 , 1 }</td><td></td></tr>
<tr><td>int preAdd[3]</td><td>{ 0 , 0 , 0 }</td><td></td></tr>
<tr><td>int postAdd[3]</td><td>{ 0 , 0 , 0 }</td><td></td></tr>
</table>
<br/>

<b>BufferCountDesc : count = (inputCount + preAdd) * multiply / divide + postAdd.  inputCount is 1 if nothing given.</b><br/><br/>
<table>
<tr><th colspan=3>BufferCountDesc</th></tr>
<tr><td>BufferNodeReference node</td><td>{}</td><td>The node referenced, if there is one.</td></tr>
<tr><td>VariableReference variable</td><td>{}</td><td>The variable referenced, if there is one.</td></tr>
<tr><td>int multiply</td><td>1</td><td></td></tr>
<tr><td>int divide</td><td>1</td><td></td></tr>
<tr><td>int preAdd</td><td>0</td><td></td></tr>
<tr><td>int postAdd</td><td>0</td><td></td></tr>
</table>
<br/>

<b>TextureFormatDesc : Specifies a texture format</b><br/><br/>
<table>
<tr><th colspan=3>TextureFormatDesc</th></tr>
<tr><td>TextureNodeReference node</td><td>{}</td><td>This node's format is used, if specified</td></tr>
<tr><td>TextureFormat format</td><td>TextureFormat::Any</td><td>A specific format can be specified</td></tr>
<tr><td>VariableReference variable</td><td>{}</td><td>The variable that holds the texture format. Assumed to be a uint32.</td></tr>
</table>
<br/>

<b>BufferFormatDesc : Specifies a buffer format</b><br/><br/>
<table>
<tr><th colspan=3>BufferFormatDesc</th></tr>
<tr><td>BufferNodeReference node</td><td>{}</td><td>This node's format is used, if specified</td></tr>
<tr><td>StructReference structureType</td><td>{}</td><td>The buffer type, if it is a structured buffer</td></tr>
<tr><td>DataFieldType type</td><td>DataFieldType::Count</td><td>The buffer type. May become a typed or structured buffer, depending on the type chosen.</td></tr>
</table>
<br/>

<b>ResourceDependency : Specifies a resource dependency</b><br/><br/>
<table>
<tr><th colspan=3>ResourceDependency</th></tr>
<tr><td><i>int nodeIndex</i></td><td>-1</td><td>The index of the resource node.</td></tr>
<tr><td><i>int pinIndex</i></td><td>-1</td><td>The pin index of this action node</td></tr>
<tr><td><i>ShaderResourceAccessType access</i></td><td>ShaderResourceAccessType::Count</td><td>How the resource is accessed.</td></tr>
<tr><td><i>ShaderResourceType type</i></td><td>ShaderResourceType::Count</td><td>What type of resource it is.</td></tr>
</table>
<br/>

<b>SetCBFromVar : Specify that a structure field should be set to the value of a variable</b><br/><br/>
<table>
<tr><th colspan=3>SetCBFromVar</th></tr>
<tr><td>std::string field</td><td>""</td><td>The name of the field to set</td></tr>
<tr><td>VariableReference variable</td><td>{}</td><td>The name of the variable to take the value from</td></tr>
</table>
<br/>

<b>ColorTargetSettings : Settings for a color target in a draw call</b><br/><br/>
<table>
<tr><th colspan=3>ColorTargetSettings</th></tr>
<tr><td>bool clear</td><td>false</td><td>If true, clears the color target before drawing</td></tr>
<tr><td>float clearColor[4]</td><td>{ 1.0f , 1.0f , 1.0f , 1.0f}</td><td>The color to clear the render target</td></tr>
<tr><td>bool writeChannels[4]</td><td>{ true , true , true , true }</td><td>Controls whether R,G,B,A get written or not</td></tr>
<tr><td>bool enableBlending</td><td>false</td><td>Enables alpha blending</td></tr>
<tr><td>DrawBlendMode srcBlend</td><td>DrawBlendMode::One</td><td></td></tr>
<tr><td>DrawBlendMode destBlend</td><td>DrawBlendMode::Zero</td><td></td></tr>
<tr><td>DrawBlendMode srcBlendAlpha</td><td>DrawBlendMode::One</td><td></td></tr>
<tr><td>DrawBlendMode destBlendAlpha</td><td>DrawBlendMode::Zero</td><td></td></tr>
<tr><td>int arrayIndex</td><td>0</td><td>The array index, for Texture2DArray, Texture3D etc</td></tr>
<tr><td>int mipLevel</td><td>0</td><td>The mip to use</td></tr>
</table>
<br/>

<b>SubgraphDataVariable : Variables in the subgraph</b><br/><br/>
<table>
<tr><th colspan=3>SubgraphDataVariable</th></tr>
<tr><td>std::string name</td><td>""</td><td>variable name</td></tr>
<tr><td>VariableVisibility visibility</td><td>VariableVisibility::Internal</td><td>Who can see and interact with this variable</td></tr>
</table>
<br/>

<b>SubGraphData : Cached data about a subgraph</b><br/><br/>
<table>
<tr><th colspan=3>SubGraphData</th></tr>
<tr><td>std::string importedResources[]</td><td></td><td>input output pins</td></tr>
<tr><td>std::string exportedResources[]</td><td></td><td>output only pins</td></tr>
<tr><td>SubgraphDataVariable variables[]</td><td></td><td>Variables in the subgraph</td></tr>
</table>
<br/>

<b>SubGraphVariableSettings : Cached data about a subgraph</b><br/><br/>
<table>
<tr><th colspan=3>SubGraphVariableSettings</th></tr>
<tr><td>std::string name</td><td>""</td><td>variable name</td></tr>
<tr><td>VariableVisibility visibility</td><td>VariableVisibility::Internal</td><td>Who can see and interact with this variable</td></tr>
<tr><td>std::string replaceWithStr</td><td>{}</td><td>If set, the subgraph variable will be deleted and all references will use this parent graph variable instead.</td></tr>
<tr><td>std::string replaceWithValue</td><td>{}</td><td>Replace the variable with a literal value. At gigi compile time it makes an internal private variable of the correct type with this string as the default value.</td></tr>
<tr><td>bool isLoopIndex</td><td>false</td><td>If true, this variable will recieve the loop index.</td></tr>
<tr><td>VariableReference replaceWith</td><td>{}</td><td>If set, the subgraph variable will be deleted and all references will use this parent graph variable instead.</td></tr>
</table>
<br/>

<b>LinkProperties : Properties of links between nodes.</b><br/><br/>
<table>
<tr><th colspan=3>LinkProperties</th></tr>
<tr><td>int UAVMipIndex</td><td>0</td><td>The mip index to use, if this is a UAV connection.</td></tr>
<tr><td>bool disallowDuplication</td><td>false</td><td>If you plug an output pin into multiple input pins, and some of them are reads and some of them are writes, Gigi will make copies for the reads by default.  You can check this box to have it read from the original resource instead of making a copy, but doing so may result in a race condition.</td></tr>
<tr><td>MemoryUnitOfMeasurement bufferViewUnits</td><td>MemoryUnitOfMeasurement::Items</td><td>How bufferViewBegin and bufferViewSize are measured: in number of items, or number of bytes.</td></tr>
<tr><td>unsigned int bufferViewBegin</td><td>0</td><td>Where the buffer view starts.  If items, the index of first element of the view of a buffer. For raw buffers, this is the number of uint32s.</td></tr>
<tr><td>VariableReference bufferViewBeginVariable</td><td>{}</td><td>If specified, this variable will control where buffer views begin.</td></tr>
<tr><td>unsigned int bufferViewSize</td><td>0</td><td>How big the buffer view is, or 0 for the entire thing, starting from bufferViewBegin. Will use the minimum of this, and the actual size of the buffer.  If items, the count of items in the view of a buffer. For raw buffers, this is the number of uint32s.</td></tr>
<tr><td>VariableReference bufferViewSizeVariable</td><td>{}</td><td>If specified, this variable will control the buffer view size.</td></tr>
</table>
<br/>

<b>CopyResource_BufferToBuffer : Settings for when copying from a buffer to a buffer</b><br/><br/>
<table>
<tr><th colspan=3>CopyResource_BufferToBuffer</th></tr>
<tr><td>unsigned int srcBegin</td><td>0</td><td>Where the copy source begins in the source buffer. In Bytes.</td></tr>
<tr><td>unsigned int destBegin</td><td>0</td><td>Where the copy destination begins in the destination buffer. In Bytes.</td></tr>
<tr><td>unsigned int size</td><td>0</td><td>How much to copy. 0 to copy everything. In Bytes.</td></tr>
<tr><td><i>bool hideUI</i></td><td>false</td><td>Used by UI system to know whether to show this or not</td></tr>
</table>
<br/>

<b>ShaderVariableAlias : Specify a variable alias</b><br/><br/>
<table>
<tr><th colspan=3>ShaderVariableAlias</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the alias. The name used in the /*$(VariableAlias:name)*/ tag in the shader.</td></tr>
<tr><td>VariableReference variable</td><td>{}</td><td></td></tr>
</table>
<br/>

<b>ShaderVariableAliases : Specify a variable alias</b><br/><br/>
<table>
<tr><th colspan=3>ShaderVariableAliases</th></tr>
<tr><td>ShaderVariableAlias aliases[]</td><td></td><td></td></tr>
<tr><td><i>int shaderIndex</i></td><td>-1</td><td></td></tr>
</table>
<br/>

<b>RenderGraphNode_Base : The base type of all node types</b><br/><br/>
<table>
<tr><th colspan=3>RenderGraphNode_Base</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the node</td></tr>
<tr><td>BackendRestriction backends</td><td>{}</td><td>This node can be limited to specific backends</td></tr>
<tr><td>std::string comment</td><td>""</td><td>A comment about the node which can appear in generated code</td></tr>
<tr><td>float editorPos[2]</td><td>{ 0.0f , 0.0f }</td><td>The position of the node in the editor</td></tr>
<tr><td><i>std::unordered_map<std::string COMMA int> inputPinIds</i></td><td>{}</td><td></td></tr>
<tr><td><i>std::unordered_map<std::string COMMA int> outputPinIds</i></td><td>{}</td><td></td></tr>
<tr><td><i>int nodeIndex</i></td><td>-1</td><td>The index in the list of render graph nodes. This is filled in after loading by the ReferenceFixupVisitor and is in [0,N) with no gaps.</td></tr>
<tr><td><i>std::string originalName</i></td><td>""</td><td>The name before renames and sanitization</td></tr>
</table>
<br/>

<b>RenderGraphNode_ResourceBase : The base type for resource node types</b><br/><br/>
<table>
<tr><th colspan=3>RenderGraphNode_ResourceBase - Inherits from RenderGraphNode_Base</th></tr>
<tr><td>bool transient</td><td>true</td><td>A non transient resource will persist across executions and frames. A transient resource may not, and is decided by the backend as a potential optimization opportunity.</td></tr>
<tr><td><b>inline static const bool c_isResourceNode</b></td><td>true</td><td>Whether or not this is a resource node.</td></tr>
<tr><td><i>ShaderResourceAccessType startingState</i></td><td>ShaderResourceAccessType::Count</td><td>The first state that a reosurce is in. Calculated for convenience.</td></tr>
<tr><td><i>ShaderResourceAccessType finalState</i></td><td>ShaderResourceAccessType::Count</td><td>The last state that a reosurce is in. Calculated for convenience.</td></tr>
<tr><td><i>unsigned int accessedAs</i></td><td>0</td><td>A bitfield of all the ways this resource is accessed (ShaderResourceAccessType). Useful for creating resources with the correct usage flags.</td></tr>
<tr><td><i>unsigned int originallyAccessedAs</i></td><td>0</td><td>Same as accessedAs, but uses original access instead of access, in case access was modified</td></tr>
</table>
<br/>

<b>RenderGraphNode_ActionBase : The base type for action node types</b><br/><br/>
<table>
<tr><th colspan=3>RenderGraphNode_ActionBase - Inherits from RenderGraphNode_Base</th></tr>
<tr><td><b>inline static const bool c_isResourceNode</b></td><td>false</td><td>Whether or not this is a resource node.</td></tr>
<tr><td><i>ResourceDependency resourceDependencies[]</i></td><td></td><td>Filled in before backend code is called.</td></tr>
<tr><td>Condition condition</td><td>{}</td><td>An optional condition added for the action to happen</td></tr>
<tr><td>LinkProperties linkProperties[]</td><td></td><td>Specify array index / mip level for each pin. Should be same size and order as GetNodePins family of functons.</td></tr>
<tr><td>NodePinConnection connections[]</td><td></td><td>What is plugged into the pins</td></tr>
<tr><td>bool hideInViewer</td><td>false</td><td>Whether this node is only intermediate and should be hidden in a viewer.</td></tr>
</table>
<br/>

<b>RenderGraphNode_Resource_Buffer : Declares a buffer</b><br/><br/>
<table>
<tr><th colspan=3>RenderGraphNode_Resource_Buffer - Inherits from RenderGraphNode_ResourceBase</th></tr>
<tr><td><b>inline static const std::string c_editorName</b></td><td>"Buffer"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shortTypeName</b></td><td>"Buffer"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shorterTypeName</b></td><td>"Buff"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const bool c_showInEditor</b></td><td>true</td><td>Used by the editor.</td></tr>
<tr><td>ResourceVisibility visibility</td><td>ResourceVisibility::Internal</td><td>Who can see the buffer and who owns it</td></tr>
<tr><td>BufferFormatDesc format</td><td>{}</td><td>The format of the texture.</td></tr>
<tr><td>BufferCountDesc count</td><td>{}</td><td>How many items are in the buffer.</td></tr>
</table>
<br/>

<b>RenderGraphNode_Resource_ShaderConstants : Declares a shader constant buffer</b><br/><br/>
<table>
<tr><th colspan=3>RenderGraphNode_Resource_ShaderConstants - Inherits from RenderGraphNode_ResourceBase</th></tr>
<tr><td><b>inline static const std::string c_editorName</b></td><td>"Constants"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shortTypeName</b></td><td>"Constants"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shorterTypeName</b></td><td>"Const"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const bool c_showInEditor</b></td><td>false</td><td>Used by the editor.</td></tr>
<tr><td>StructReference structure</td><td>{}</td><td>The structure of the constant buffer.</td></tr>
<tr><td>SetCBFromVar setFromVar[]</td><td></td><td>Set constant buffer (left) to the value of variable (right) every execution</td></tr>
</table>
<br/>

<b>Resource_Texture_MSAA : Sttings only used for Texture2DMS</b><br/><br/>
<table>
<tr><th colspan=3>Resource_Texture_MSAA</th></tr>
<tr><td>unsigned int sampleCount</td><td>2</td><td>MSAA sample count, usually 2 or 4, most hardware also has 8 and some even 16 or more.</td></tr>
<tr><td><i>bool hideUI</i></td><td>false</td><td>Used by UI system to know whether to show this or not</td></tr>
</table>
<br/>

<b>RenderGraphNode_Resource_Texture : Declares a texture</b><br/><br/>
<table>
<tr><th colspan=3>RenderGraphNode_Resource_Texture - Inherits from RenderGraphNode_ResourceBase</th></tr>
<tr><td><b>inline static const std::string c_editorName</b></td><td>"Texture"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shortTypeName</b></td><td>"Texture"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shorterTypeName</b></td><td>"Tex"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const bool c_showInEditor</b></td><td>true</td><td>Used by the editor.</td></tr>
<tr><td>ResourceVisibility visibility</td><td>ResourceVisibility::Internal</td><td>Who can see the texture and who owns it</td></tr>
<tr><td>TextureFormatDesc format</td><td>{}</td><td>The format of the texture.</td></tr>
<tr><td>TextureSizeDesc size</td><td>{}</td><td>The size of the texture.</td></tr>
<tr><td>unsigned int numMips</td><td>1</td><td>The number of mips the texture should have. 0 means the full set. 1 means just the full size image, and no smaller mips.</td></tr>
<tr><td>TextureDimensionType dimension</td><td>TextureDimensionType::Texture2D</td><td>The dimensionality of the texture</td></tr>
<tr><td><i>std::string loadFileName</i></td><td>""</td><td>If not empty, it load it as an image. This is currently not exposed to users, and is created when shaders use an image token</td></tr>
<tr><td><i>bool loadFileNameAsSRGB</i></td><td>true</td><td>If true, the source file is treated as sRGB</td></tr>
<tr><td>Resource_Texture_MSAA msaaSettings</td><td>{}</td><td>MSAA Settings for Texture2DMS, multiple samples are stored per pixel for antialiasing</td></tr>
</table>
<br/>

<b>RenderGraphNode_Action_ComputeShader : Executes a compute shader</b><br/><br/>
<table>
<tr><th colspan=3>RenderGraphNode_Action_ComputeShader - Inherits from RenderGraphNode_ActionBase</th></tr>
<tr><td><b>inline static const std::string c_editorName</b></td><td>"Compute Shader"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shortTypeName</b></td><td>"Compute"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shorterTypeName</b></td><td>"CS"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const bool c_showInEditor</b></td><td>true</td><td>Used by the editor.</td></tr>
<tr><td>ComputeShaderReference shader</td><td>{}</td><td>The shader.</td></tr>
<tr><td>ShaderVariableAliases shaderVariableAliases</td><td>{}</td><td></td></tr>
<tr><td>DispatchSizeDesc dispatchSize</td><td>{}</td><td>The dispatch size.</td></tr>
<tr><td>std::string entryPoint</td><td>""</td><td>The shader entrypoint. Overrides the shader entry entryPoint. Handled by front end during Gigi compilation and becomes shader entry point during code gen.</td></tr>
<tr><td>ShaderDefine defines[]</td><td></td><td>The defines the shader is compiled with, on top of whatever defines the shader has already. Handled by front end during Gigi compilation and becomes shader defines during code gen.</td></tr>
</table>
<br/>

<b>RenderGraphNode_Action_RayShader : Executes a dispatch rays shader</b><br/><br/>
<table>
<tr><th colspan=3>RenderGraphNode_Action_RayShader - Inherits from RenderGraphNode_ActionBase</th></tr>
<tr><td><b>inline static const std::string c_editorName</b></td><td>"Ray Gen Shader"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shortTypeName</b></td><td>"RayGen"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shorterTypeName</b></td><td>"RGS"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const bool c_showInEditor</b></td><td>true</td><td>Used by the editor.</td></tr>
<tr><td>RayGenShaderReference shader</td><td>{}</td><td>The ray gen shader.</td></tr>
<tr><td>ShaderVariableAliases shaderVariableAliases</td><td>{}</td><td></td></tr>
<tr><td>RayDispatchSizeDesc dispatchSize</td><td>{}</td><td>The dispatch size.</td></tr>
<tr><td>std::string entryPoint</td><td>""</td><td>The shader entrypoint. Overrides the shader entry entryPoint.  Handled by front end during Gigi compilation and becomes shader entry point during code gen.</td></tr>
<tr><td>ShaderDefine defines[]</td><td></td><td>The defines the shader is compiled with, on top of whatever defines the shader has already. Handled by front end during Gigi compilation and becomes shader defines during code gen.</td></tr>
<tr><td>int maxRecursionDepth</td><td>3</td><td>The maximum recursion depth of the ray.</td></tr>
<tr><td>unsigned int rayPayloadSize</td><td>64</td><td>The size of the ray payload, in bytes. 64 bytes is four float4s.</td></tr>
</table>
<br/>

<b>RenderGraphNode_Action_CopyResource : Copies a resource to another resource</b><br/><br/>
<table>
<tr><th colspan=3>RenderGraphNode_Action_CopyResource - Inherits from RenderGraphNode_ActionBase</th></tr>
<tr><td><b>inline static const std::string c_editorName</b></td><td>"Copy Resource"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shortTypeName</b></td><td>"Copy"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shorterTypeName</b></td><td>"Copy"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const bool c_showInEditor</b></td><td>true</td><td>Used by the editor.</td></tr>
<tr><td>CopyResource_BufferToBuffer bufferToBuffer</td><td>{}</td><td>Settings when copying from a buffer to another buffer.</td></tr>
<tr><td>NodePinReference source</td><td>{}</td><td>The resource being copied from.</td></tr>
<tr><td>NodePinReference dest</td><td>{}</td><td>The resource being copied to.</td></tr>
</table>
<br/>

<b>RenderGraphNode_Action_DrawCall : Rasterization</b><br/><br/>
<table>
<tr><th colspan=3>RenderGraphNode_Action_DrawCall - Inherits from RenderGraphNode_ActionBase</th></tr>
<tr><td><b>inline static const std::string c_editorName</b></td><td>"Draw Call"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shortTypeName</b></td><td>"Draw"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shorterTypeName</b></td><td>"Draw"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const bool c_showInEditor</b></td><td>true</td><td>Used by the editor.</td></tr>
<tr><td>AmplificationShaderReferenceOptional amplificationShader</td><td>{}</td><td>The amplification shader.</td></tr>
<tr><td>ShaderVariableAliases amplificationShaderVariableAliases</td><td>{}</td><td></td></tr>
<tr><td>MeshShaderReferenceOptional meshShader</td><td>{}</td><td>The mesh shader.</td></tr>
<tr><td>ShaderVariableAliases meshShaderVariableAliases</td><td>{}</td><td></td></tr>
<tr><td>VertexShaderReferenceOptional vertexShader</td><td>{}</td><td>The vertex shader.</td></tr>
<tr><td>ShaderVariableAliases vertexShaderVariableAliases</td><td>{}</td><td></td></tr>
<tr><td>PixelShaderReference pixelShader</td><td>{}</td><td>The pixel shader.</td></tr>
<tr><td>ShaderVariableAliases pixelShaderVariableAliases</td><td>{}</td><td></td></tr>
<tr><td>NodePinReferenceOptional indirectBuffer</td><td>{}</td><td>Indirect buffer to make this draw use ExecuteIndirect</td></tr>
<tr><td>int countPerInstance</td><td>-1</td><td>If using an index buffer, this is indexCountPerInstance, else is vertexCountPerInstance.  If -1, will use the count of the buffer.  Else, if a buffer is given, will use min(buffer count, countPerInstance).</td></tr>
<tr><td>int instanceCount</td><td>1</td><td>How many instances to draw. If -1, will use the count of the instance buffer. Else, if an instance buffer is given, will use min (instance buffer count, instanceCount).</td></tr>
<tr><td>DispatchSizeDesc meshShaderDispatchSize</td><td>{}</td><td>The mesh shader dispatch size.</td></tr>
<tr><td>bool depthTargetClear</td><td>false</td><td>If true, clears the depth target before doing a draw call.</td></tr>
<tr><td>float depthTargetClearValue</td><td>0.0f</td><td>The value to clear the depth target to.</td></tr>
<tr><td>bool depthWrite</td><td>true</td><td>If false, disables writing to the depth buffer</td></tr>
<tr><td>int depthArrayIndex</td><td>0</td><td>The array index, for Texture2DArray, Texture3D etc</td></tr>
<tr><td>int depthMipLevel</td><td>0</td><td>The mip to use</td></tr>
<tr><td>DepthTestFunction depthTest</td><td>DepthTestFunction::Less</td><td></td></tr>
<tr><td>bool stencilClear</td><td>false</td><td>If true, clears the stencil before doing a draw call.</td></tr>
<tr><td>uint8_t stencilClearValue</td><td>0</td><td></td></tr>
<tr><td>uint8_t stencilRef</td><td>0</td><td>Sets the reference value for depth stencil tests.</td></tr>
<tr><td>uint8_t stencilReadMask</td><td>255</td><td></td></tr>
<tr><td>uint8_t stencilWriteMask</td><td>255</td><td></td></tr>
<tr><td>StencilOp frontFaceStencilFail</td><td>StencilOp::Keep</td><td>When stencil test fails</td></tr>
<tr><td>StencilOp backFaceStencilFail</td><td>StencilOp::Keep</td><td>When stencil test fails</td></tr>
<tr><td>StencilOp frontFaceStencilDepthFail</td><td>StencilOp::Keep</td><td>When stencil passes but depth fails</td></tr>
<tr><td>StencilOp backFaceStencilDepthFail</td><td>StencilOp::Keep</td><td>When stencil passes but depth fails</td></tr>
<tr><td>StencilOp frontFaceStencilPass</td><td>StencilOp::Keep</td><td>When stencil and depth both pass</td></tr>
<tr><td>StencilOp backFaceStencilPass</td><td>StencilOp::Keep</td><td>When stencil and depth both pass</td></tr>
<tr><td>DepthTestFunction frontFaceStencilFunc</td><td>DepthTestFunction::Always</td><td>How to test stencil data against existing stencil data</td></tr>
<tr><td>DepthTestFunction backFaceStencilFunc</td><td>DepthTestFunction::Always</td><td>How to test stencil data against existing stencil data</td></tr>
<tr><td>bool conservativeRasterization</td><td>false</td><td>Turns on conservative rasterization</td></tr>
<tr><td>bool alphaAsCoverage</td><td>false</td><td>Turns on alpha as coverage</td></tr>
<tr><td>bool independentAlpha</td><td>false</td><td>If false, colorTargetSettings[0] defines blend mode for all color targets</td></tr>
<tr><td>ColorTargetSettings colorTargetSettings[8]</td><td>{}</td><td>Settings for the color targets</td></tr>
<tr><td>ShaderDefine defines[]</td><td></td><td>The defines the shaders ares compiled with, on top of whatever defines the shaders have already. Handled by front end during Gigi compilation and becomes shader defines during code gen.</td></tr>
<tr><td>DrawCullMode cullMode</td><td>DrawCullMode::None</td><td></td></tr>
<tr><td>bool frontIsCounterClockwise</td><td>true</td><td></td></tr>
<tr><td>ShadingRate shadingRate</td><td>ShadingRate::_1x1</td><td>For variable rate shading</td></tr>
<tr><td>ShadingRateCombiner shadingRateCombiner1</td><td>ShadingRateCombiner::PassThrough</td><td>For variable rate shading. This combines the provoking vertex shading rate with the rate set by the command list.</td></tr>
<tr><td>ShadingRateCombiner shadingRateCombiner2</td><td>ShadingRateCombiner::PassThrough</td><td>For variable rate shading. This combines the image based shading rate with the shading rate set by the command list and provoking vertex.</td></tr>
<tr><td>NodePinReferenceOptional shadingRateImage</td><td>{}</td><td>The image used to determine shading rate on the screen. Must be a 2d texture with format R8_Uint.</td></tr>
<tr><td>NodePinReferenceOptional vertexBuffer</td><td>{}</td><td>The vertex buffer being rendered. If not given, a vertexCount needs to be given.</td></tr>
<tr><td>NodePinReferenceOptional indexBuffer</td><td>{}</td><td>Index buffer for vertex buffer (Optional).</td></tr>
<tr><td>NodePinReferenceOptional instanceBuffer</td><td>{}</td><td>Instance buffer (Optional).</td></tr>
<tr><td>NodePinReferenceOptional colorTargets[8]</td><td>{}</td><td>Color Targets</td></tr>
<tr><td>NodePinReferenceOptional depthTarget</td><td>{}</td><td>Depth Target</td></tr>
<tr><td>GeometryType geometryType</td><td>GeometryType::TriangleList</td><td>What to draw</td></tr>
</table>
<br/>

<b>RenderGraphNode_Action_SubGraph : Runs another Gigi technique</b><br/><br/>
<table>
<tr><th colspan=3>RenderGraphNode_Action_SubGraph - Inherits from RenderGraphNode_ActionBase</th></tr>
<tr><td><b>inline static const std::string c_editorName</b></td><td>"Subgraph"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shortTypeName</b></td><td>"Subgraph"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shorterTypeName</b></td><td>"Sub"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const bool c_showInEditor</b></td><td>true</td><td>Used by the editor.</td></tr>
<tr><td>std::string fileName</td><td>""</td><td>Relative file name</td></tr>
<tr><td>SubGraphData subGraphData</td><td>{}</td><td>A cache of the interface of the other graph.</td></tr>
<tr><td>SubGraphVariableSettings variableSettings[]</td><td></td><td>Per variable settings for subgraph variables.</td></tr>
<tr><td>int loopCount</td><td>1</td><td>Number of times to execute the technique.</td></tr>
<tr><td>VariableReferenceConstOnly loopCountVariable</td><td>{}</td><td>The variable to use for the loopCount. Only const variables supported currently.</td></tr>
<tr><td><i>int loopIndex</i></td><td>-1</td><td>When unrolling subgraph loops, the loop index of the node is stored here.</td></tr>
</table>
<br/>

<b>RenderGraphNode_Action_Barrier : Causes all input operations to be executed before anything plugged into the output</b><br/><br/>
<table>
<tr><th colspan=3>RenderGraphNode_Action_Barrier - Inherits from RenderGraphNode_ActionBase</th></tr>
<tr><td><b>inline static const std::string c_editorName</b></td><td>"Barrier"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shortTypeName</b></td><td>"Barrier"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shorterTypeName</b></td><td>"Bar"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const bool c_showInEditor</b></td><td>true</td><td>Used by the editor.</td></tr>
</table>
<br/>

<b>RenderGraphNode_Reroute : Used in editor only to reroute links</b><br/><br/>
<table>
<tr><th colspan=3>RenderGraphNode_Reroute - Inherits from RenderGraphNode_ActionBase</th></tr>
<tr><td><b>inline static const std::string c_editorName</b></td><td>"Reroute"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shortTypeName</b></td><td>"Reroute"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shorterTypeName</b></td><td>"Rr"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const bool c_showInEditor</b></td><td>false</td><td>Used by the editor.</td></tr>
</table>
<br/>

<b>PreviewMsg_Ping : The client and server send this periodically to know the other is still alive. It fails to send if the connection closes.</b><br/><br/>
<table>
<tr><th colspan=3>PreviewMsg_Ping</th></tr>
</table>
<br/>

<b>PreviewMsgCS_Version : The client tells the server what Gigi version it is using</b><br/><br/>
<table>
<tr><th colspan=3>PreviewMsgCS_Version</th></tr>
<tr><td>std::string version</td><td>""</td><td>Gigi Version</td></tr>
</table>
<br/>

<b>PreviewMsgCS_Log : The client tells the server what Gigi version it is using</b><br/><br/>
<table>
<tr><th colspan=3>PreviewMsgCS_Log</th></tr>
<tr><td>PreviewMsgCS_Log_Level level</td><td>PreviewMsgCS_Log_Level::Info</td><td>The type of message</td></tr>
<tr><td>std::string msg</td><td>""</td><td>The log message</td></tr>
</table>
<br/>

<b>PreviewMsgSC_VersionResponse : The server tells the client whether or not the version is ok.</b><br/><br/>
<table>
<tr><th colspan=3>PreviewMsgSC_VersionResponse</th></tr>
<tr><td>bool versionOK</td><td>false</td><td>Whether the gigi version is ok or not.</td></tr>
</table>
<br/>

<b>PreviewMsgSC_LoadGGFile : The client tells the server to load a gg file</b><br/><br/>
<table>
<tr><th colspan=3>PreviewMsgSC_LoadGGFile</th></tr>
<tr><td>std::string fileName</td><td>""</td><td>The path and name of the .gg file to load</td></tr>
<tr><td>bool preserveState</td><td>true</td><td>If true, camera state etc should be preserved</td></tr>
</table>
<br/>

<b>GGUserFile_ImportedTexture : The details of an imported texture</b><br/><br/>
<table>
<tr><th colspan=3>GGUserFile_ImportedTexture</th></tr>
<tr><td>std::string fileName</td><td>""</td><td>The image file loaded</td></tr>
<tr><td>bool fileIsSRGB</td><td>true</td><td>Whether the file is an sRGB file or not</td></tr>
<tr><td>bool makeMips</td><td>false</td><td>Whether to make mips or no</td></tr>
<tr><td>int size[3]</td><td>{0 , 0 , 1}</td><td>The size of the image to create</td></tr>
<tr><td>float color[4]</td><td>{ 1 , 1 , 1 , 1}</td><td>The color of the image to create, or the tint of the loaded file</td></tr>
<tr><td>TextureFormat format</td><td>TextureFormat::RGBA8_Unorm_sRGB</td><td>The format of the texture to create</td></tr>
<tr><td>int binaryDims[3]</td><td>{0 , 0 , 1}</td><td>The size of the image in the binary file</td></tr>
<tr><td>TextureFormat binaryFormat</td><td>TextureFormat::RGBA8_Unorm_sRGB</td><td>The format of the binary file</td></tr>
</table>
<br/>

<b>GGUserFile_ImportedBuffer : The details of an imported buffer</b><br/><br/>
<table>
<tr><th colspan=3>GGUserFile_ImportedBuffer</th></tr>
<tr><td>std::string fileName</td><td>""</td><td>The file loaded</td></tr>
<tr><td>bool CSVHeaderRow</td><td>true</td><td>If reading a CSV, and this is true, it will skip everything up to the first newline, to ignore a header row.</td></tr>
<tr><td>int structIndex</td><td>-1</td><td>the index of the struct if a structured buffer</td></tr>
<tr><td>DataFieldType type</td><td>DataFieldType::Count</td><td>The data field type, if not a structured buffer</td></tr>
<tr><td>int count</td><td>1</td><td>how many items are stored</td></tr>
<tr><td>GGUserFile_TLASBuildFlags RT_BuildFlags</td><td>GGUserFile_TLASBuildFlags::PreferFastTrace</td><td>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_PREFER_FAST_TRACE etc</td></tr>
<tr><td>bool BLASOpaque</td><td>false</td><td>DXR BLAS Option</td></tr>
<tr><td>bool BLASNoDuplicateAnyhitInvocations</td><td>false</td><td>DXR BLAS Option</td></tr>
<tr><td>GGUserFile_BLASCullMode BLASCullMode</td><td>GGUserFile_BLASCullMode::CullNone</td><td>BLAS triangle culling settings</td></tr>
<tr><td>bool IsAABBs</td><td>false</td><td>Set to true if ray tracing AABBs with intersection shaders. Format is Min XYZ, Max XYZ.</td></tr>
<tr><td>float GeometryTransform[16]</td><td>{ 1.0f , 0.0f , 0.0f , 0.0f , 0.0f , 1.0f , 0.0f , 0.0f , 0.0f , 0.0f , 1.0f , 0.0f , 0.0f , 0.0f , 0.0f , 1.0f }</td><td>A 4x4 matrix to transform pos, normal, tangent.</td></tr>
<tr><td>CooperativeVectorData cvData</td><td>{}</td><td>Data needed for cooperative vectors support for imported buffer resources</td></tr>
</table>
<br/>

<b>GGUserFile_ImportedResource : The details of an imported resource</b><br/><br/>
<table>
<tr><th colspan=3>GGUserFile_ImportedResource</th></tr>
<tr><td>std::string nodeName</td><td>""</td><td>The name of the node this imported texture data is for</td></tr>
<tr><td>bool resetEveryFrame</td><td>true</td><td>Whether this texture should be reset every frame, or if the technique is allowed to change it over multiple frames</td></tr>
<tr><td>bool isATexture</td><td>true</td><td>Is it a texture or a buffer</td></tr>
<tr><td>GGUserFile_ImportedTexture texture</td><td>{}</td><td>Texture data</td></tr>
<tr><td>GGUserFile_ImportedBuffer buffer</td><td>{}</td><td>Buffer data</td></tr>
</table>
<br/>

<b>GGUserFile_Camera : </b><br/><br/>
<table>
<tr><th colspan=3>GGUserFile_Camera</th></tr>
<tr><td>bool perspective</td><td>true</td><td>Perspective if true, orthographic if false.</td></tr>
<tr><td>bool leftHanded</td><td>true</td><td>Left handed if true, right handed if false.</td></tr>
<tr><td>bool reverseZ</td><td>true</td><td>If true, reverses the depth values for more precision. https://developer.nvidia.com/content/depth-precision-visualized</td></tr>
<tr><td>float nearPlane</td><td>0.1f</td><td>The distance to the near plane.</td></tr>
<tr><td>float farPlane</td><td>1000.0f</td><td>The distance to the far plane. Set to zero for infinite Z.</td></tr>
<tr><td>float FOV</td><td>45.0f</td><td>Vertical field of view, in degrees</td></tr>
<tr><td>float flySpeed</td><td>0.1f</td><td>How fast the WASD keys move in the world</td></tr>
<tr><td>float mouseSensitivity</td><td>0.01f</td><td>How fast the mouse rotates the camera</td></tr>
<tr><td>GGUserFile_CameraJitterType jitterType</td><td>GGUserFile_CameraJitterType::Halton23</td><td>The sequence of the jittered projection matrix</td></tr>
<tr><td>int jitterLength</td><td>16</td><td>The length of the sequence used to jitter the jittered projection matrix. 0 means infinite.</td></tr>
<tr><td>float startingCameraPos[3]</td><td>{ 0.0f , 0.0f , -10.0f }</td><td></td></tr>
<tr><td>float startingCameraAltitudeAzimuth[2]</td><td>{ 0.0f , 0.0f }</td><td></td></tr>
<tr><td><i>float cameraPos[3]</i></td><td>{0.0f , 0.0f , -10.0f}</td><td></td></tr>
<tr><td><i>float cameraAltitudeAzimuth[2]</i></td><td>{0.0f , 0.0f}</td><td></td></tr>
<tr><td><i>bool cameraChanged</i></td><td>false</td><td></td></tr>
</table>
<br/>

<b>GGUserFile_SystemVars : </b><br/><br/>
<table>
<tr><th colspan=3>GGUserFile_SystemVars</th></tr>
<tr><td>std::string iResolution_varName</td><td>"iResolution"</td><td></td></tr>
<tr><td>std::string iResolution_textureName</td><td>""</td><td></td></tr>
<tr><td>std::string iTime_varName</td><td>"iTime"</td><td></td></tr>
<tr><td>std::string iTimeDelta_varName</td><td>"iTimeDelta"</td><td></td></tr>
<tr><td>std::string iFrameRate_varName</td><td>"iFrameRate"</td><td></td></tr>
<tr><td>std::string iFrame_varName</td><td>"iFrame"</td><td></td></tr>
<tr><td>std::string iMouse_varName</td><td>"iMouse"</td><td></td></tr>
<tr><td>std::string MouseState_varName</td><td>"MouseState"</td><td></td></tr>
<tr><td>std::string MouseStateLastFrame_varName</td><td>"MouseStateLastFrame"</td><td></td></tr>
<tr><td>std::string WindowSize_varName</td><td>"WindowSize"</td><td></td></tr>
<tr><td>GGUserFile_Camera camera</td><td>{}</td><td>The camera settings. Can pluralize if one isn't enough.</td></tr>
<tr><td>std::string ProjMtx_textureName</td><td>""</td><td>The projection matrix needs a resolution to calculate for. Choose a texture node and that will be used as a resolution.</td></tr>
<tr><td>std::string ViewMtx_varName</td><td>"ViewMtx"</td><td></td></tr>
<tr><td>std::string InvViewMtx_varName</td><td>"InvViewMtx"</td><td></td></tr>
<tr><td>std::string ProjMtx_varName</td><td>"ProjMtx"</td><td></td></tr>
<tr><td>std::string InvProjMtx_varName</td><td>"InvProjMtx"</td><td></td></tr>
<tr><td>std::string ViewProjMtx_varName</td><td>"ViewProjMtx"</td><td></td></tr>
<tr><td>std::string InvViewProjMtx_varName</td><td>"InvViewProjMtx"</td><td></td></tr>
<tr><td>std::string JitteredProjMtx_varName</td><td>"JitteredProjMtx"</td><td>ProjMtx with jitter.</td></tr>
<tr><td>std::string InvJitteredProjMtx_varName</td><td>"InvJitteredProjMtx"</td><td>Inverted ProjMtx with jitter.</td></tr>
<tr><td>std::string JitteredViewProjMtx_varName</td><td>"JitteredViewProjMtx"</td><td>ViewProjMtx with jitter.</td></tr>
<tr><td>std::string InvJitteredViewProjMtx_varName</td><td>"InvJitteredViewProjMtx"</td><td>Inverted ViewProjMtx with jitter.</td></tr>
<tr><td>std::string CameraPos_varName</td><td>"CameraPos"</td><td></td></tr>
<tr><td>std::string CameraAltitudeAzimuth_varName</td><td>"CameraAltitudeAzimuth"</td><td></td></tr>
<tr><td>std::string CameraChanged_varName</td><td>"CameraChanged"</td><td></td></tr>
<tr><td>std::string CameraJitter_varName</td><td>"CameraJitter"</td><td></td></tr>
<tr><td>std::string CameraFOV_varName</td><td>"CameraFOV"</td><td></td></tr>
<tr><td>std::string CameraNearPlane_varName</td><td>"CameraNearPlane"</td><td></td></tr>
<tr><td>std::string CameraFarPlane_varName</td><td>"CameraFarPlane"</td><td></td></tr>
<tr><td>std::string ShadingRateImageTileSize_varName</td><td>"ShadingRateImageTileSize"</td><td></td></tr>
<tr><td>std::string KeyState_bufferName</td><td>""</td><td>256 entries for the keys this frame, and 256 entries for the keys last frame. 512 entries total.</td></tr>
</table>
<br/>

<b>GGUserFile_SavedVariable : Saved Variable Values</b><br/><br/>
<table>
<tr><th colspan=3>GGUserFile_SavedVariable</th></tr>
<tr><td>std::string name</td><td>""</td><td></td></tr>
<tr><td>std::string value</td><td>""</td><td></td></tr>
</table>
<br/>

<b>GGUserFileV1 : The contents of a .gguser file</b><br/><br/>
<table>
<tr><th colspan=3>GGUserFileV1</th></tr>
<tr><td>std::string version</td><td>"1.0"</td><td>The version of the .gguser file</td></tr>
<tr><td>GGUserFile_SystemVars systemVars</td><td>{}</td><td></td></tr>
<tr><td>int resourceViewType</td><td>0</td><td>The type of resource being viewed</td></tr>
<tr><td>int resourceViewNodeIndex</td><td>-1</td><td>The index of the node bieng viewed</td></tr>
<tr><td>int resourceViewResourceIndex</td><td>-1</td><td>The index of that resource within that node being used</td></tr>
<tr><td>int syncInterval</td><td>1</td><td>IDXGISwapChain::Present() parameter: Synchronize presentation after the nth vertical blank.</td></tr>
<tr><td>GGUserFile_ImportedResource importedResources[]</td><td></td><td></td></tr>
<tr><td>GGUserFile_SavedVariable savedVariables[]</td><td></td><td></td></tr>
</table>
<br/>

<b>GGUserFileV2Snapshot : The snapshot of a GGUserFileV2</b><br/><br/>
<table>
<tr><th colspan=3>GGUserFileV2Snapshot</th></tr>
<tr><td>std::string name</td><td>""</td><td>The snapshot name</td></tr>
<tr><td>int resourceViewType</td><td>0</td><td>The type of resource being viewed</td></tr>
<tr><td>int resourceViewNodeIndex</td><td>-1</td><td>The index of the node bieng viewed</td></tr>
<tr><td>int resourceViewResourceIndex</td><td>-1</td><td>The index of that resource within that node being used</td></tr>
<tr><td>bool loadVars</td><td>true</td><td>Whether variables will be loaded from this snapshot</td></tr>
<tr><td>bool loadCamera</td><td>true</td><td>Whether the camera will be loaded from this snapshot</td></tr>
<tr><td>bool loadResources</td><td>true</td><td>Whether imported resources will be loaded from this snapshot</td></tr>
<tr><td>bool loadView</td><td>true</td><td>Whether the resource viewed will be loaded from this snapshot</td></tr>
<tr><td>float cameraPos[3]</td><td>{ 0.0f , 0.0f , - 10.0f }</td><td>Used by snapshots to capture the camera position</td></tr>
<tr><td>float cameraAltitudeAzimuth[2]</td><td>{ 0.0f , 0.0f }</td><td>Used by snapshots to capture the camera orientation</td></tr>
<tr><td>GGUserFile_ImportedResource importedResources[]</td><td></td><td></td></tr>
<tr><td>GGUserFile_SavedVariable savedVariables[]</td><td></td><td></td></tr>
</table>
<br/>

<b>GGUserFileV2 : The contents of a .gguser file</b><br/><br/>
<table>
<tr><th colspan=3>GGUserFileV2</th></tr>
<tr><td>std::string version</td><td>"2.0"</td><td>The version of the .gguser file</td></tr>
<tr><td>int syncInterval</td><td>1</td><td>IDXGISwapChain::Present() parameter: Synchronize presentation after the nth vertical blank.</td></tr>
<tr><td>GGUserFile_SystemVars systemVars</td><td>{}</td><td></td></tr>
<tr><td>GGUserFileV2Snapshot snapshot</td><td>{}</td><td></td></tr>
<tr><td>GGUserFileV2Snapshot snapshots[]</td><td></td><td></td></tr>
</table>
<br/>

<b>GGUserFileVersionOnly : Only the version of the .gguser file</b><br/><br/>
<table>
<tr><th colspan=3>GGUserFileVersionOnly</th></tr>
<tr><td>std::string version</td><td>"1.0"</td><td>The version of the .gguser file</td></tr>
</table>
<br/>

<b>GGViewerConfig : The config file for the viewer settings file ViewerConfig.json</b><br/><br/>
<table>
<tr><th colspan=3>GGViewerConfig</th></tr>
<tr><td>std::string version</td><td>"1.0"</td><td>The version of the file</td></tr>
<tr><td>std::string keyCameraForward</td><td>"W"</td><td>Camera forward key</td></tr>
<tr><td>std::string keyCameraLeft</td><td>"A"</td><td>Camera left key</td></tr>
<tr><td>std::string keyCameraBackward</td><td>"S"</td><td>Camera back key</td></tr>
<tr><td>std::string keyCameraRight</td><td>"D"</td><td>Camera right key</td></tr>
<tr><td>std::string keyCameraUp</td><td>"E"</td><td>Camera right key</td></tr>
<tr><td>std::string keyCameraDown</td><td>"Q"</td><td>Camera down key</td></tr>
<tr><td>std::string keyCameraFast</td><td>"Shift"</td><td>Camera fast key</td></tr>
<tr><td>std::string keyCameraSlow</td><td>"Control"</td><td>Camera slow key</td></tr>
</table>
<br/>

<b>BrowserServerInfo : </b><br/><br/>
<table>
<tr><th colspan=3>BrowserServerInfo</th></tr>
<tr><td>std::string Name</td><td>""</td><td></td></tr>
<tr><td>std::string Repo</td><td>""</td><td></td></tr>
<tr><td>std::string Branch</td><td>""</td><td></td></tr>
<tr><td>std::string TechniqueList</td><td>""</td><td></td></tr>
</table>
<br/>

<b>BrowserTechniqueSummary : </b><br/><br/>
<table>
<tr><th colspan=3>BrowserTechniqueSummary</th></tr>
<tr><td>std::string Repo</td><td>""</td><td>The repo. Usually begins with https and ends with .git.</td></tr>
<tr><td>std::string Commit</td><td>""</td><td>The commit hash to look at in that repo.</td></tr>
<tr><td>std::string DetailsFile</td><td>""</td><td>The path of the json file containing BrowserTechniqueDetails of the technique. This location is recursively downloaded when the download button is pressed.</td></tr>
<tr><td>std::string ListedDate</td><td>""</td><td>A date in the form YYYY-MM-DD</td></tr>
</table>
<br/>

<b>BrowserTechniqueSummaries : </b><br/><br/>
<table>
<tr><th colspan=3>BrowserTechniqueSummaries</th></tr>
<tr><td>BrowserTechniqueSummary Techniques[]</td><td></td><td></td></tr>
</table>
<br/>

<b>BrowserTechniqueDetails : </b><br/><br/>
<table>
<tr><th colspan=3>BrowserTechniqueDetails</th></tr>
<tr><td>std::string Title</td><td>""</td><td></td></tr>
<tr><td>std::string Description</td><td>""</td><td></td></tr>
<tr><td>std::string Author</td><td>""</td><td></td></tr>
<tr><td>std::string Tags</td><td>""</td><td>Separated by commas</td></tr>
<tr><td>std::string Technique</td><td>"The .gg file to open. Relative to DetailsFile."</td><td></td></tr>
<tr><td>std::string Website</td><td>""</td><td>[Optional] A website to view and/or discuss your technique. For instance, the github page.</td></tr>
<tr><td>std::string Screenshot</td><td>""</td><td>The image shown that goes with your technique. Relative to DetailsFile.</td></tr>
<tr><td>std::string License</td><td>""</td><td>The file describing the license of your technique. Relative to DetailsFile.</td></tr>
<tr><td>std::string GigiVersion</td><td>""</td><td>The version of Gigi used to make this technique.</td></tr>
</table>
<br/>

<b>BrowserCachedTechnique : </b><br/><br/>
<table>
<tr><th colspan=3>BrowserCachedTechnique</th></tr>
<tr><td>BrowserTechniqueSummary Summary</td><td>{}</td><td></td></tr>
<tr><td>BrowserTechniqueDetails Details</td><td>{}</td><td></td></tr>
<tr><td>bool Downloaded</td><td>false</td><td></td></tr>
<tr><td>BrowserServerInfo Origin</td><td>{}</td><td></td></tr>
</table>
<br/>

<b>BrowserCachedTechniques : </b><br/><br/>
<table>
<tr><th colspan=3>BrowserCachedTechniques</th></tr>
<tr><td>BrowserCachedTechnique Techniques[]</td><td></td><td></td></tr>
</table>
<br/>

<b>BackendTemplateFileProperties : File Properties</b><br/><br/>
<table>
<tr><th colspan=3>BackendTemplateFileProperties</th></tr>
<tr><td>std::string fileName</td><td>""</td><td>The name of the file this is the properties for.</td></tr>
<tr><td>std::string renameTo</td><td>""</td><td>If not blank, what to rename the file to. May use the /*$(Name)*/ Gigi token.</td></tr>
<tr><td>bool isDirectory</td><td>false</td><td>If this is a directory, set this to true to make this apply to all files in the directory recursively.</td></tr>
<tr><td>bool onlyIncludeIfRaytracing</td><td>false</td><td>If a file should only be copied when the render graph uses raytracing, set this to true.</td></tr>
<tr><td>bool onlyIncludeIfDX12AgilitySDKRequired</td><td>false</td><td>If a file should only be copied when the dx12 agility sdk is required, set this to true</td></tr>
<tr><td>BackendTemplateFileType type</td><td>BackendTemplateFileType::Output</td><td>The type of the file determines what happens to it during code generation</td></tr>
</table>
<br/>

<b>BackendTemplateNodeTemplate : Template text for specific tags, for specific nodes</b><br/><br/>
<table>
<tr><th colspan=3>BackendTemplateNodeTemplate</th></tr>
<tr><td>std::string nodeType</td><td>""</td><td>The type of node this template is for.</td></tr>
<tr><td>std::string tag</td><td>""</td><td>The tag that this template is for.</td></tr>
<tr><td>std::string text</td><td>""</td><td>The text body of the template</td></tr>
</table>
<br/>

<b>BackendTemplateConfig : Backend Template Config</b><br/><br/>
<table>
<tr><th colspan=3>BackendTemplateConfig</th></tr>
<tr><td>BackendTemplateFileProperties fileProperties[]</td><td></td><td>Properties for files in a backend template directory</td></tr>
<tr><td>std::string ignoreDirectories[]</td><td></td><td>Do not process a directory as template files</td></tr>
<tr><td>std::string nodeTemplateFiles[]</td><td></td><td>The files to process into node templates</td></tr>
<tr><td><i>BackendTemplateNodeTemplate nodeTemplates[]</i></td><td></td><td>calculated at runtime, from nodeTemplateFiles</td></tr>
</table>
<br/>

<b>WebGPU_RWTextureSplit : </b><br/><br/>
<table>
<tr><th colspan=3>WebGPU_RWTextureSplit</th></tr>
<tr><td>std::string nodeName</td><td>""</td><td>The name of the shader affected</td></tr>
<tr><td>std::string shaderName</td><td>""</td><td>The name of the shader affected</td></tr>
<tr><td>std::string pinName</td><td>""</td><td>The name of the pin affected. This pin is also write only.</td></tr>
<tr><td>std::string pinNameR</td><td>""</td><td>The name of the read only version of the pin.</td></tr>
</table>
<br/>

<b>BackendData_WebGPU : </b><br/><br/>
<table>
<tr><th colspan=3>BackendData_WebGPU</th></tr>
<tr><td>WebGPU_RWTextureSplit RWTextureSplits[]</td><td></td><td>All RW textures that got split into an R texture and a W texture</td></tr>
</table>
<br/>

<b>BackendSettings_DX12 : DX12 Settings</b><br/><br/>
<table>
<tr><th colspan=3>BackendSettings_DX12</th></tr>
<tr><td>int numSRVDescriptors</td><td>256</td><td>The number of descriptors in the internal SRV heap</td></tr>
<tr><td>int numRTVDescriptors</td><td>256</td><td>The number of descriptors in the internal RTV heap</td></tr>
<tr><td>int numDSVDescriptors</td><td>256</td><td>The number of descriptors in the internal DSV heap</td></tr>
<tr><td>DXShaderCompiler shaderCompiler</td><td>DXShaderCompiler::DXC</td><td>The shader compiler to use</td></tr>
<tr><td>std::string shaderModelCs</td><td>"cs_6_1"</td><td>The default shader model to use for compute shaders</td></tr>
<tr><td>std::string shaderModelVs</td><td>"vs_6_1"</td><td>The default shader model to use for vertex shaders</td></tr>
<tr><td>std::string shaderModelPs</td><td>"ps_6_1"</td><td>The default shader model to use for pixel shaders</td></tr>
<tr><td>std::string shaderModelRayShaders</td><td>"lib_6_3"</td><td>The default shader model to use for ray shaders</td></tr>
<tr><td>std::string shaderModelAs</td><td>"as_6_5"</td><td>The default shader model to use for amplification shaders</td></tr>
<tr><td>std::string shaderModelMs</td><td>"ms_6_5"</td><td>The default shader model to use for mesh shaders</td></tr>
<tr><td>bool DXC_HLSL_2021</td><td>false</td><td>When using DXC, use HLSL 2021.  https://github.com/microsoft/DirectXShaderCompiler/wiki/HLSL-2021</td></tr>
<tr><td>bool Allow16BitTypes</td><td>false</td><td>DXC option -enable-16bit-types. Only usable for shader model >= 6.1, and HLSL language >= 2018.</td></tr>
<tr><td>bool AgilitySDKRequired</td><td>false</td><td>True if the agility SDK is required in DX12. Can be set to true in the editor, but can also be set to true by the compiler.</td></tr>
</table>
<br/>

<b>BackendSettings_UE_5_3 : UE_5_3 Settings</b><br/><br/>
<table>
<tr><th colspan=3>BackendSettings_UE_5_3</th></tr>
<tr><td>bool AllowRealTypes</td><td>false</td><td>CFLAG_AllowRealTypes. For 16 bit shader types.</td></tr>
</table>
<br/>

<b>BackendSettings_WebGPU_Features : Required Limits. For more info, see: https://developer.mozilla.org/en-US/docs/Web/API/GPUSupportedFeatures</b><br/><br/>
<table>
<tr><th colspan=3>BackendSettings_WebGPU_Features</th></tr>
<tr><td>bool float32Filterable</td><td>false</td><td>float32-filterable. When enabled, allows filtering of r32float-, rg32float-, and rgba32float-format GPUTextures.</td></tr>
<tr><td>bool subgroups</td><td>false</td><td>subgroups. When enabled, allows the use of subgroups in WGSL. Subgroups enable SIMD-level parallelism, allowing threads in a workgroup
to communicate and execute collective math operations such as calculating a sum of numbers, and offering an efficient method for
cross-thread data sharing. Note that the subgroupMinSize and subgroupMaxSize properties can be useful to check if, for example, you have a
hardcoded algorithm that requires a subgroup of a certain size. You can use f16 values with subgroups when you request a GPUDevice with
both the shader-f16 and subgroups features.</td></tr>
</table>
<br/>

<b>BackendSettings_WebGPU_Limits : Required features. For more info, see: https://developer.mozilla.org/en-US/docs/Web/API/GPUSupportedLimits</b><br/><br/>
<table>
<tr><th colspan=3>BackendSettings_WebGPU_Limits</th></tr>
<tr><td>unsigned int maxStorageBuffersPerShaderStage</td><td>0</td><td>maxStorageBuffersPerShaderStage. 0 for default.</td></tr>
<tr><td>unsigned int maxStorageTexturesPerShaderStage</td><td>0</td><td>maxStorageTexturesPerShaderStage. 0 for default.</td></tr>
<tr><td>unsigned int maxComputeWorkgroupStorageSize</td><td>0</td><td>maxComputeWorkgroupStorageSize. 0 for default.</td></tr>
</table>
<br/>

<b>BackendSettings_WebGPU : WebGPU Settings. For the capabilities of your browser and machine, see: https://webgpureport.org/</b><br/><br/>
<table>
<tr><th colspan=3>BackendSettings_WebGPU</th></tr>
<tr><td>BackendSettings_WebGPU_Features features</td><td>{}</td><td></td></tr>
<tr><td>BackendSettings_WebGPU_Limits limits</td><td>{}</td><td></td></tr>
</table>
<br/>

<b>BackendSettings_Common : Common Settings</b><br/><br/>
<table>
<tr><th colspan=3>BackendSettings_Common</th></tr>
<tr><td>bool debugNames</td><td>true</td><td>If true, sets debug names to GPU objects on available platforms.</td></tr>
<tr><td>bool debugShaders</td><td>true</td><td>If true, compiles shaders with debug options turned on, on available platforms.</td></tr>
<tr><td>bool shaderWarningAsErrors</td><td>false</td><td>If true, compiles shaders with warnings as errors turned on</td></tr>
<tr><td>bool createPDBsAndBinaries</td><td>false</td><td>If true, will output PDBs and shader binaries, useful for crash debugging. Also needed for rga.exe to run.</td></tr>
<tr><td>std::string rgaPath</td><td>"C:\\Apps\\RadeonDeveloperToolSuite\\rga.exe"</td><td>The default path where rga.exe can be found.
This is rarly needed, onlky works with DX12 and only used to generate a .bat as part of pbd export for AMD disassembly and shader stats.
see https://gpuopen.com/radeon-gpu-analyzer-2-2-direct3d12-compute</td></tr>
<tr><td>std::string rgaASIC</td><td>"gfx1032"</td><td>The hardware generation to target for rga.exe
gfx1032: AMD Radeon PRO W6600
See .bat for more info</td></tr>
</table>
<br/>

<b>BackendSettings : Backend settings</b><br/><br/>
<table>
<tr><th colspan=3>BackendSettings</th></tr>
<tr><td>BackendSettings_DX12 dx12</td><td>{}</td><td></td></tr>
<tr><td>BackendSettings_WebGPU webGPU</td><td>{}</td><td></td></tr>
<tr><td>BackendSettings_UE_5_3 UE_5_3</td><td>{}</td><td></td></tr>
<tr><td>BackendSettings_Common common</td><td>{}</td><td></td></tr>
</table>
<br/>

<b>BackendData : Backend Data</b><br/><br/>
<table>
<tr><th colspan=3>BackendData</th></tr>
<tr><td>BackendData_WebGPU webGPU</td><td>{}</td><td></td></tr>
</table>
<br/>

<b>BuildSettings : Backend settings</b><br/><br/>
<table>
<tr><th colspan=3>BuildSettings</th></tr>
<tr><td>GigiCompileWarning disableWarnings[]</td><td></td><td>Warnings listed here will be suppressed</td></tr>
<tr><td>bool makeGraphViz</td><td>false</td><td>If true, will generate graphviz when building this technique</td></tr>
<tr><td>std::string outDX12</td><td>"out/dx12/"</td><td>The output location for DX12</td></tr>
<tr><td>std::string outUE_5_3</td><td>"out/UE_5_3/"</td><td>The output location for UE 5.3</td></tr>
<tr><td>std::string outWebGPU</td><td>"out/WebGPU/"</td><td>The output location for WebGPU</td></tr>
<tr><td><i>std::string outInterpreter</i></td><td>"out/interpreter/"</td><td>The output location for the interpreter backend</td></tr>
</table>
<br/>

<b>ConfigFromBackend : Frontend configuration set by the backend.</b><br/><br/>
<table>
<tr><th colspan=3>ConfigFromBackend</th></tr>
<tr><td>bool RTSceneTakesSRVSlot</td><td>true</td><td>If true, RT scenes will take an SRV register slot.</td></tr>
</table>
<br/>

<b>StyleSettings : Graph style settings.</b><br/><br/>
<table>
<tr><th colspan=3>StyleSettings</th></tr>
<tr><td>float resourceNodeColor[3]</td><td>{ 128.f / 255.f , 128.f / 255.f , 1.f }</td><td>Color of the resource node types.</td></tr>
<tr><td>float nonTransientResourceNodeColor[3]</td><td>{ 128.f / 255.f , 128.f / 255.f , 1.f }</td><td>Color of the non transient resource node types.</td></tr>
<tr><td>float actionNodeColor[3]</td><td>{ 1.f , 128.f / 255.f , 64.f / 255.f }</td><td>Color of the action node types.</td></tr>
</table>
<br/>

<b>ResourceTransition : A single resource transition</b><br/><br/>
<table>
<tr><th colspan=3>ResourceTransition</th></tr>
<tr><td>int nodeIndex</td><td>-1</td><td>The node for the resource being transitioned.</td></tr>
<tr><td>ShaderResourceAccessType oldState</td><td>ShaderResourceAccessType::Count</td><td>The previous state</td></tr>
<tr><td>ShaderResourceAccessType newState</td><td>ShaderResourceAccessType::Count</td><td>The next state</td></tr>
</table>
<br/>

<b>ResourceTransitions : A list of resource transitions</b><br/><br/>
<table>
<tr><th colspan=3>ResourceTransitions</th></tr>
<tr><td>ResourceTransition transitions[]</td><td></td><td>A list of resource transitions</td></tr>
</table>
<br/>

<b>FileCopy : A description of a file to copy into the output package</b><br/><br/>
<table>
<tr><th colspan=3>FileCopy</th></tr>
<tr><td>std::string fileName</td><td>""</td><td>The file to copy.</td></tr>
<tr><td>FileCopyType type</td><td>FileCopyType::Private</td><td>The type of file it is</td></tr>
<tr><td>std::string destFileName</td><td>""</td><td>If empty, uses fileName</td></tr>
<tr><td>BackendRestriction backends</td><td>{}</td><td>The backends this file copy happens for.</td></tr>
<tr><td>bool binary</td><td>false</td><td>If false, it will be treated as a text file, undergo string replacement, and line ending normalization. If true, it will be copied without modification.</td></tr>
<tr><td>bool plural</td><td>false</td><td>If true, this file copy is a file pattern for possibly several files to copy.  The filename should contain a %i and all files from 0 to N at that location in the file name will be copied.</td></tr>
</table>
<br/>

<b>SetVariable : A variable modification</b><br/><br/>
<table>
<tr><th colspan=3>SetVariable</th></tr>
<tr><td>VariableReferenceNoConst destination</td><td>{}</td><td>The variable to set.  destination = A (operator) B.</td></tr>
<tr><td>int destinationIndex</td><td>-1</td><td>The index of the field in the destination variable. -1 means no index.</td></tr>
<tr><td>VariableReference AVar</td><td>{}</td><td>The variable on the left side of the operator</td></tr>
<tr><td>int AVarIndex</td><td>-1</td><td>The index of the field in the A variable. -1 means no index.</td></tr>
<tr><td>TextureOrBufferNodeReference ANode</td><td>{}</td><td>If specified, the size of this resource will be used. AVarIndex will index into it if multi dimensional.</td></tr>
<tr><td>std::string ALiteral</td><td>""</td><td>The value to use, if no variable is set</td></tr>
<tr><td>SetVariableOperator op</td><td>SetVariableOperator::Add</td><td></td></tr>
<tr><td>VariableReference BVar</td><td>{}</td><td>The variable on the right side of the operator</td></tr>
<tr><td>int BVarIndex</td><td>-1</td><td>The index of the field in the B variable. -1 means no index.</td></tr>
<tr><td>TextureOrBufferNodeReference BNode</td><td>{}</td><td>If specified, the size of this resource will be used. BVarIndex will index into it if multi dimensional.</td></tr>
<tr><td>std::string BLiteral</td><td>""</td><td>The value to use, if no variable is set</td></tr>
<tr><td>bool setBefore</td><td>true</td><td>If true, this happens before execution. If false, happens after execution.</td></tr>
<tr><td>Condition condition</td><td>{}</td><td>An optional condition added for the action to happen</td></tr>
</table>
<br/>

<b>VariableReplacement : When subgraph variables are replaced by parent variables, this gives the breadcrumbs needed to find that.</b><br/><br/>
<table>
<tr><th colspan=3>VariableReplacement</th></tr>
<tr><td>std::string srcScope</td><td>""</td><td></td></tr>
<tr><td>std::string srcName</td><td>""</td><td></td></tr>
<tr><td>std::string destName</td><td>""</td><td></td></tr>
</table>
<br/>

<b>CustomGigiToken : Allows you to give values for custom gigi tokens, such as /*$(CopyrightHeader)*/. All unknown Gigi tokens are replaced with empty string by default.</b><br/><br/>
<table>
<tr><th colspan=3>CustomGigiToken</th></tr>
<tr><td>std::string key</td><td>""</td><td>The name of the gigi token without markup, such as CopyrightHeader for /*$(CopyrightHeader)*/</td></tr>
<tr><td>std::string value</td><td>""</td><td>The value to replace the token with</td></tr>
</table>
<br/>

<b>EditorGroupNode : Data for group nodes in the editor</b><br/><br/>
<table>
<tr><th colspan=3>EditorGroupNode</th></tr>
<tr><td>std::string name</td><td>""</td><td>Name of the group</td></tr>
<tr><td><i>int32_t id</i></td><td>0</td><td>Id of the group</td></tr>
<tr><td>float position[2]</td><td>{ 0.f , 0.f }</td><td>Position of the group</td></tr>
<tr><td>float size[2]</td><td>{ 0.f , 0.f }</td><td>Size of the group</td></tr>
<tr><td>float color[4]</td><td>{ 1.f , 1.f , 1.f , 0.25f }</td><td>Color of the group</td></tr>
</table>
<br/>

<b>RenderGraph : The root type of the render graph</b><br/><br/>
<table>
<tr><th colspan=3>RenderGraph</th></tr>
<tr><td>std::string name</td><td>"Unnamed"</td><td>The name of the render graph.</td></tr>
<tr><td>std::string comment</td><td>""</td><td>Put author information, links, etc here.</td></tr>
<tr><td>std::string version</td><td>""</td><td>The gigi version of the render graph.</td></tr>
<tr><td><i>std::string schema</i></td><td>""</td><td>The schema file read from the file originally, so we can put it back as it was.</td></tr>
<tr><td>Variable variables[]</td><td></td><td>The render graph variables. Used for getting parameters from the host app and user. Can be referenced by many things in the render graph such as texture size and shader constants.</td></tr>
<tr><td>Shader shaders[]</td><td></td><td>The shaders used by the render graph.</td></tr>
<tr><td>Struct structs[]</td><td></td><td>The structs used by the render graph.</td></tr>
<tr><td>FileCopy fileCopies[]</td><td></td><td>Files to copy during the building process.</td></tr>
<tr><td>RenderGraphNode nodes[]</td><td></td><td>The render graph nodes.</td></tr>
<tr><td>Enum enums[]</td><td></td><td>Enums</td></tr>
<tr><td>SetVariable setVars[]</td><td></td><td>Variables to modify at the beginning or end of the render graph</td></tr>
<tr><td>RTHitGroup hitGroups[]</td><td></td><td>Ray tracing hit group definitions</td></tr>
<tr><td>BackendSettings settings</td><td>{}</td><td>Backend settings</td></tr>
<tr><td>BuildSettings buildSettings</td><td>{}</td><td>Build settings</td></tr>
<tr><td>StyleSettings styleSettings</td><td>{}</td><td>Style settings</td></tr>
<tr><td>CustomGigiToken customTokens[]</td><td></td><td>Allows you to give values for custom gigi tokens, such as /*$(CopyrightHeader)*/. All unknown Gigi tokens are replaced with empty string by default.</td></tr>
<tr><td>TextureNodeReference PrimaryOutput</td><td>{}</td><td>A hint to anything that might be able to use this information, such as generated code or the viewer.</td></tr>
<tr><td>EditorGroupNode editorGroupNodes[]</td><td></td><td>Editor group nodes</td></tr>
<tr><td><i>std::string baseDirectory</i></td><td>""</td><td>The relative location of the render graph file.</td></tr>
<tr><td><i>std::string outputDirectory</i></td><td>""</td><td>Where the render graph output should go (this field used by the compiler).</td></tr>
<tr><td><i>std::vector<int> flattenedNodeList</i></td><td>{}</td><td>The flattened list of nodes, in the order they should be executed in. Calculated before being given to back end code.</td></tr>
<tr><td><i>std::vector<ResourceTransitions> transitions</i></td><td>{}</td><td>The resource transitions that want to happen before each node executes. Calculated before being given to back end code.</td></tr>
<tr><td><i>Backend backend</i></td><td>Backend::DX12</td><td>The backend currently being ran</td></tr>
<tr><td><i>ConfigFromBackend configFromBackend</i></td><td>{}</td><td>Information communicated to the front end, by the back end.</td></tr>
<tr><td><i>bool usesRaytracing</i></td><td>false</td><td>True if this render graph uses ray tracing.</td></tr>
<tr><td><i>std::string editorFileName</i></td><td>""</td><td>The name and path of the file name in the editor</td></tr>
<tr><td><i>std::string subGGGraphFileNames[]</i></td><td></td><td>The list of absolute path sugraph gg files this render graph relies on. Useful for file watches from the viewer.</td></tr>
<tr><td><i>VariableReplacement variableReplacements[]</i></td><td></td><td>When subgraph variables are replaced by parent variables, this gives the breadcrumbs needed to find that.</td></tr>
<tr><td><i>bool versionUpgraded</i></td><td>false</td><td>Set to true if the loading code did a version upgrade. The editor uses this to mark the document as dirty.</td></tr>
<tr><td><i>std::string versionUpgradedFrom</i></td><td>""</td><td>The version it was upgraded from</td></tr>
<tr><td><i>std::string versionUpgradedMessage</i></td><td>""</td><td>Text to show about the version upgrade</td></tr>
<tr><td><i>BackendTemplateConfig templateConfig</i></td><td>{}</td><td>Code generation template config</td></tr>
<tr><td><i>bool generateGraphVizFlag</i></td><td>false</td><td>Set to true if the generating GraphViz. Should be set to true from a command line parameter</td></tr>
<tr><td><i>std::vector<std::string> assertsFormatStrings</i></td><td>{}</td><td>The unique formatting strings of the asserts messages</td></tr>
<tr><td><i>std::unordered_set<std::string> firedAssertsIdentifiers</i></td><td>{}</td><td>The identifiers of the fired asserts to ignore them later on</td></tr>
<tr><td><i>BackendData backendData</i></td><td>{}</td><td>Backend Data</td></tr>
</table>
<br/>


<h1>Variants</h1>
<b>RenderGraphNode : Render graph node variant</b><br/><br/>
<table>
<tr><th colspan=3>RenderGraphNode</th></tr>
<tr><td>RenderGraphNode_Resource_Buffer resourceBuffer</td><td>{}</td><td></td></tr>
<tr><td>RenderGraphNode_Resource_ShaderConstants resourceShaderConstants</td><td>{}</td><td></td></tr>
<tr><td>RenderGraphNode_Resource_Texture resourceTexture</td><td>{}</td><td></td></tr>
<tr><td>RenderGraphNode_Reroute reroute</td><td>{}</td><td></td></tr>
<tr><td>RenderGraphNode_Action_ComputeShader actionComputeShader</td><td>{}</td><td></td></tr>
<tr><td>RenderGraphNode_Action_RayShader actionRayShader</td><td>{}</td><td></td></tr>
<tr><td>RenderGraphNode_Action_CopyResource actionCopyResource</td><td>{}</td><td></td></tr>
<tr><td>RenderGraphNode_Action_DrawCall actionDrawCall</td><td>{}</td><td></td></tr>
<tr><td>RenderGraphNode_Action_SubGraph actionSubGraph</td><td>{}</td><td></td></tr>
<tr><td>RenderGraphNode_Action_Barrier actionBarrier</td><td>{}</td><td></td></tr>
</table>
<br/>

<b>PreviewMsgClientToServer : Viewer client to server messages</b><br/><br/>
<table>
<tr><th colspan=3>PreviewMsgClientToServer</th></tr>
<tr><td>PreviewMsg_Ping ping</td><td>{}</td><td></td></tr>
<tr><td>PreviewMsgCS_Version version</td><td>{}</td><td></td></tr>
<tr><td>PreviewMsgCS_Log log</td><td>{}</td><td></td></tr>
</table>
<br/>

<b>PreviewMsgServerToClient : Viewer server to client messages</b><br/><br/>
<table>
<tr><th colspan=3>PreviewMsgServerToClient</th></tr>
<tr><td>PreviewMsg_Ping ping</td><td>{}</td><td></td></tr>
<tr><td>PreviewMsgSC_VersionResponse versionResponse</td><td>{}</td><td></td></tr>
<tr><td>PreviewMsgSC_LoadGGFile loadGGFile</td><td>{}</td><td></td></tr>
</table>
<br/>


</html>
