<html>
<style>
table, th, td, tr
{
    border: 1px solid black;
    border-collapse: collapse;
}
</style>

<h1>Enums</h1>
<b>Backend : </b><br/><br/>
<table>
<tr><th colspan=2>Backend</th></tr>
<tr><td>DX12</td><td></td></tr>
<tr><td>Interpreter</td><td></td></tr>
</table>
<br/>

<b>ShaderResourceType : The type of a shader resource</b><br/><br/>
<table>
<tr><th colspan=2>ShaderResourceType</th></tr>
<tr><td>Texture</td><td>Unordered Access View (Read/Write)</td></tr>
<tr><td>Buffer</td><td>Shader Resource View</td></tr>
<tr><td>ConstantBuffer</td><td>Constant Buffer View</td></tr>
<tr><td>Count</td><td></td></tr>
</table>
<br/>

<b>ShaderResourceAccessType : The type of a shader resource</b><br/><br/>
<table>
<tr><th colspan=2>ShaderResourceAccessType</th></tr>
<tr><td>UAV</td><td>Unordered Access View (Read/Write)</td></tr>
<tr><td>SRV</td><td>Shader Resource View</td></tr>
<tr><td>CBV</td><td>Constant Buffer View</td></tr>
<tr><td>CopySource</td><td>SRV copy source</td></tr>
<tr><td>CopyDest</td><td>SRV copy dest</td></tr>
<tr><td>Indirect</td><td>Used in Execute Indirect</td></tr>
<tr><td>RTScene</td><td>The scene for raytracing (acceleration structure)</td></tr>
<tr><td>VertexBuffer</td><td>Used as a vertex buffer</td></tr>
<tr><td>IndexBuffer</td><td>Used as an index buffer</td></tr>
<tr><td>RenderTarget</td><td>Used as a color buffer</td></tr>
<tr><td>DepthTarget</td><td>Used as a depth buffer</td></tr>
<tr><td>Barrier</td><td>Used by the barrier node</td></tr>
<tr><td>ShadingRate</td><td>Used as a shading rate image</td></tr>
<tr><td>Count</td><td></td></tr>
</table>
<br/>

<b>DataFieldType : The type of a data field</b><br/><br/>
<table>
<tr><th colspan=2>DataFieldType</th></tr>
<tr><td>Int</td><td>int</td></tr>
<tr><td>Int2</td><td>int[2]</td></tr>
<tr><td>Int3</td><td>int[3]</td></tr>
<tr><td>Int4</td><td>int[4]</td></tr>
<tr><td>Uint</td><td>uint</td></tr>
<tr><td>Uint2</td><td>uint[2]</td></tr>
<tr><td>Uint3</td><td>uint[3]</td></tr>
<tr><td>Uint4</td><td>uint[4]</td></tr>
<tr><td>Float</td><td>float</td></tr>
<tr><td>Float2</td><td>float[2]</td></tr>
<tr><td>Float3</td><td>float[3]</td></tr>
<tr><td>Float4</td><td>float[4]</td></tr>
<tr><td>Bool</td><td>bool</td></tr>
<tr><td>Float4x4</td><td>float[4][4]</td></tr>
<tr><td>Uint_16</td><td>a 16 bit uint</td></tr>
<tr><td>Count</td><td></td></tr>
</table>
<br/>

<b>TextureViewType : The type that a texture is actually viewed as, in a shader. A subset of DataFieldType.</b><br/><br/>
<table>
<tr><th colspan=2>TextureViewType</th></tr>
<tr><td>Int</td><td>int</td></tr>
<tr><td>Int4</td><td>int[4]</td></tr>
<tr><td>Uint</td><td>uint</td></tr>
<tr><td>Uint4</td><td>uint[4]</td></tr>
<tr><td>Float</td><td>float</td></tr>
<tr><td>Float2</td><td>float[2]</td></tr>
<tr><td>Float3</td><td>float[3]</td></tr>
<tr><td>Float4</td><td>float[4]</td></tr>
</table>
<br/>

<b>SamplerFilter : The type of filter a sampler uses</b><br/><br/>
<table>
<tr><th colspan=2>SamplerFilter</th></tr>
<tr><td>MinMagMipPoint</td><td>Point</td></tr>
<tr><td>MinMagLinear_MipPoint</td><td>Bilinear</td></tr>
<tr><td>MinMagMipLinear</td><td>Trilinear</td></tr>
<tr><td>Count</td><td></td></tr>
</table>
<br/>

<b>SamplerAddressMode : The sampler address mode</b><br/><br/>
<table>
<tr><th colspan=2>SamplerAddressMode</th></tr>
<tr><td>Clamp</td><td>Clamp</td></tr>
<tr><td>Wrap</td><td>Wrap</td></tr>
<tr><td>Border</td><td>Border</td></tr>
<tr><td>Count</td><td></td></tr>
</table>
<br/>

<b>TextureDimensionType : The type of a texture</b><br/><br/>
<table>
<tr><th colspan=2>TextureDimensionType</th></tr>
<tr><td>Texture2D</td><td>Texture2D</td></tr>
<tr><td>Texture2DArray</td><td>Texture2DArray</td></tr>
<tr><td>Texture3D</td><td>Texture3D</td></tr>
<tr><td>TextureCube</td><td>TextureCube</td></tr>
</table>
<br/>

<b>ShaderType : The type of a shader resource</b><br/><br/>
<table>
<tr><th colspan=2>ShaderType</th></tr>
<tr><td>Compute</td><td>Ray generation shader</td></tr>
<tr><td>RTRayGen</td><td>Ray generation shader</td></tr>
<tr><td>RTClosestHit</td><td>Closest hit shader</td></tr>
<tr><td>RTAnyHit</td><td>Any hit shader</td></tr>
<tr><td>RTIntersection</td><td>Intersection shader</td></tr>
<tr><td>RTMiss</td><td>Miss shader</td></tr>
<tr><td>Vertex</td><td>Vertex shader</td></tr>
<tr><td>Pixel</td><td>Pixel shader</td></tr>
<tr><td>Amplification</td><td>Amplification shader</td></tr>
<tr><td>Mesh</td><td>Mesh shader</td></tr>
<tr><td>Count</td><td></td></tr>
</table>
<br/>

<b>StructFieldSemantic : Used to specify if the struct field has special meaning, such as a vertex position in a vertex buffer.</b><br/><br/>
<table>
<tr><th colspan=2>StructFieldSemantic</th></tr>
<tr><td>Position</td><td>float3</td></tr>
<tr><td>Color</td><td>float4</td></tr>
<tr><td>Normal</td><td>float3</td></tr>
<tr><td>Tangent</td><td>float4</td></tr>
<tr><td>UV</td><td>float2</td></tr>
<tr><td>MaterialID</td><td>int</td></tr>
<tr><td>ShapeID</td><td>int</td></tr>
<tr><td>Count</td><td></td></tr>
</table>
<br/>

<b>VariableVisibility : The visibility of the variable</b><br/><br/>
<table>
<tr><th colspan=2>VariableVisibility</th></tr>
<tr><td>Internal</td><td>Internal to the technique.</td></tr>
<tr><td>Host</td><td>The host app has access.</td></tr>
<tr><td>User</td><td>The host app has access and it should also be exposed to the user through UI and Script, where possible.</td></tr>
<tr><td>Count</td><td></td></tr>
</table>
<br/>

<b>VariableUIHint : Hints about how the UI for a variable should look or act, if it is made into UI</b><br/><br/>
<table>
<tr><th colspan=2>VariableUIHint</th></tr>
<tr><td>Button</td><td>There should be a button that when pressed makes the value true for a single frame, else is false.</td></tr>
<tr><td>Color</td><td>This represents a color, so a color selector would be appropriate.</td></tr>
<tr><td>Drag</td><td>Use the DragX functions in imgui.</td></tr>
<tr><td>Slider</td><td>Use the SliderX functions in imgui.</td></tr>
<tr><td>Angle</td><td>This value is an angle.</td></tr>
<tr><td>Count</td><td></td></tr>
</table>
<br/>

<b>ConditionComparison : The comparison to make between the two condition values</b><br/><br/>
<table>
<tr><th colspan=2>ConditionComparison</th></tr>
<tr><td>IsFalse</td><td>Checks if value1 is false</td></tr>
<tr><td>IsTrue</td><td>Checks if value1 is true</td></tr>
<tr><td>Equals</td><td>Checks if the two values are the same</td></tr>
<tr><td>NotEquals</td><td>Checks if the two values are notthe same</td></tr>
<tr><td>LT</td><td>value1 < value2</td></tr>
<tr><td>LTE</td><td>value1 <= value2</td></tr>
<tr><td>GT</td><td>value1 > value2</td></tr>
<tr><td>GTE</td><td>value1 >= value2</td></tr>
<tr><td>Count</td><td></td></tr>
</table>
<br/>

<b>ResourceVisibility : </b><br/><br/>
<table>
<tr><th colspan=2>ResourceVisibility</th></tr>
<tr><td>Imported</td><td>Provided as input by the host application</td></tr>
<tr><td>Internal</td><td>Used internally to the technique only</td></tr>
<tr><td>Exported</td><td>Managed by the technique but visible to the host application</td></tr>
<tr><td>Count</td><td></td></tr>
</table>
<br/>

<b>DrawCullMode : </b><br/><br/>
<table>
<tr><th colspan=2>DrawCullMode</th></tr>
<tr><td>None</td><td></td></tr>
<tr><td>Front</td><td></td></tr>
<tr><td>Back</td><td></td></tr>
</table>
<br/>

<b>DepthTestFunction : </b><br/><br/>
<table>
<tr><th colspan=2>DepthTestFunction</th></tr>
<tr><td>Never</td><td></td></tr>
<tr><td>Less</td><td></td></tr>
<tr><td>Equal</td><td></td></tr>
<tr><td>LessEqual</td><td></td></tr>
<tr><td>Greater</td><td></td></tr>
<tr><td>NotEqual</td><td></td></tr>
<tr><td>GreaterEqual</td><td></td></tr>
<tr><td>Always</td><td></td></tr>
</table>
<br/>

<b>DrawBlendMode : </b><br/><br/>
<table>
<tr><th colspan=2>DrawBlendMode</th></tr>
<tr><td>Zero</td><td></td></tr>
<tr><td>One</td><td></td></tr>
<tr><td>SrcColor</td><td></td></tr>
<tr><td>InvSrcColor</td><td></td></tr>
<tr><td>SrcAlpha</td><td></td></tr>
<tr><td>InvSrcAlpha</td><td></td></tr>
<tr><td>DestAlpha</td><td></td></tr>
<tr><td>InvDestAlpha</td><td></td></tr>
<tr><td>DestColor</td><td></td></tr>
<tr><td>InvDestColor</td><td></td></tr>
</table>
<br/>

<b>StencilOp : </b><br/><br/>
<table>
<tr><th colspan=2>StencilOp</th></tr>
<tr><td>Keep</td><td></td></tr>
<tr><td>Zero</td><td></td></tr>
<tr><td>Replace</td><td></td></tr>
<tr><td>IncrementSaturate</td><td></td></tr>
<tr><td>DecrimentSaturate</td><td></td></tr>
<tr><td>Invert</td><td></td></tr>
<tr><td>Increment</td><td></td></tr>
<tr><td>Decriment</td><td></td></tr>
</table>
<br/>

<b>ShadingRate : Used by variable rate shading</b><br/><br/>
<table>
<tr><th colspan=2>ShadingRate</th></tr>
<tr><td>_1x1</td><td></td></tr>
<tr><td>_1x2</td><td></td></tr>
<tr><td>_2x1</td><td></td></tr>
<tr><td>_2x2</td><td></td></tr>
<tr><td>_2x4</td><td></td></tr>
<tr><td>_4x2</td><td></td></tr>
<tr><td>_4x4</td><td></td></tr>
</table>
<br/>

<b>ShadingRateCombiner : Used by variable rate shading</b><br/><br/>
<table>
<tr><th colspan=2>ShadingRateCombiner</th></tr>
<tr><td>PassThrough</td><td></td></tr>
<tr><td>Override</td><td></td></tr>
<tr><td>Min</td><td></td></tr>
<tr><td>Max</td><td></td></tr>
<tr><td>Sum</td><td></td></tr>
</table>
<br/>

<b>GeometryType : </b><br/><br/>
<table>
<tr><th colspan=2>GeometryType</th></tr>
<tr><td>TriangleList</td><td></td></tr>
<tr><td>LineList</td><td></td></tr>
<tr><td>PointList</td><td></td></tr>
</table>
<br/>

<b>TextureFormat : </b><br/><br/>
<table>
<tr><th colspan=2>TextureFormat</th></tr>
<tr><td>Any</td><td>Only valid for imported textures.</td></tr>
<tr><td>R8_Unorm</td><td>R 8 bit unorm</td></tr>
<tr><td>RG8_Unorm</td><td>RG 8 bit unorm</td></tr>
<tr><td>RGBA8_Unorm</td><td>RGBA 8 bit unorm</td></tr>
<tr><td>RGBA8_Unorm_sRGB</td><td>RGBA 8 bit unorm, sRGB</td></tr>
<tr><td>R8_Snorm</td><td>R 8 bit snorm</td></tr>
<tr><td>RG8_Snorm</td><td>RG 8 bit snorm</td></tr>
<tr><td>RGBA8_Snorm</td><td>RGBA 8 bit snorm</td></tr>
<tr><td>R8_Uint</td><td>R 8 bit uint</td></tr>
<tr><td>RG8_Uint</td><td>RG 8 bit uint</td></tr>
<tr><td>RGBA8_Uint</td><td>RGBA 8 bit uint</td></tr>
<tr><td>R8_Sint</td><td>R 8 bit sint</td></tr>
<tr><td>RG8_Sint</td><td>RG 8 bit sint</td></tr>
<tr><td>RGBA8_Sint</td><td>RGBA 8 bit sint</td></tr>
<tr><td>R16_Float</td><td>R 16 bit float</td></tr>
<tr><td>RG16_Float</td><td>RG 16 bit float</td></tr>
<tr><td>RGBA16_Float</td><td>RGBA 16 bit float</td></tr>
<tr><td>RGBA16_Unorm</td><td>RGBA 16 bit unorm</td></tr>
<tr><td>RGBA16_Snorm</td><td>RGBA 16 bit snorm</td></tr>
<tr><td>R32_Float</td><td>R 32 bit float</td></tr>
<tr><td>RG32_Float</td><td>RG 32 bit float</td></tr>
<tr><td>RGBA32_Float</td><td>RGBA 32 bit float</td></tr>
<tr><td>R32_Uint</td><td>R 32 bit uint</td></tr>
<tr><td>RGBA32_Uint</td><td>RGBA 32 bit uint</td></tr>
<tr><td>R11G11B10_Float</td><td>RGB 32 bit (total) float</td></tr>
<tr><td>D32_Float</td><td>32 bit float depth</td></tr>
<tr><td>D16_Unorm</td><td>16 bit unorm depth</td></tr>
<tr><td>D32_Float_S8</td><td>32 bit depth, 8 bit stencil, and 24 more bits unused</td></tr>
<tr><td>D24_Unorm_S8</td><td>24 bit depth, 8 bit stencil</td></tr>
<tr><td>BC4_Unorm</td><td>R 8 bit unorm. block compressed.</td></tr>
<tr><td>BC4_Snorm</td><td>R 8 bit snorm. block compressed.</td></tr>
<tr><td>BC5_Unorm</td><td>RG 8 bit unorm. block compressed.</td></tr>
<tr><td>BC5_Snorm</td><td>RG 8 bit snorm. block compressed.</td></tr>
<tr><td>BC7_Unorm</td><td>RGB, alpha optional. block compressed.</td></tr>
<tr><td>BC7_Unorm_sRGB</td><td>RGB, alpha optional. sRGB. block compressed.</td></tr>
<tr><td>BC6_UF16</td><td>RGB, 16 bit float unsigned. block compressed.</td></tr>
<tr><td>BC6_SF16</td><td>RGB, 16 bit float signed. block compressed.</td></tr>
</table>
<br/>

<b>PreviewMsgCS_Log_Level : </b><br/><br/>
<table>
<tr><th colspan=2>PreviewMsgCS_Log_Level</th></tr>
<tr><td>Info</td><td></td></tr>
<tr><td>Warn</td><td></td></tr>
<tr><td>Error</td><td></td></tr>
</table>
<br/>

<b>GGUserFile_TLASBuildFlags : D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_PREFER_FAST_TRACE etc</b><br/><br/>
<table>
<tr><th colspan=2>GGUserFile_TLASBuildFlags</th></tr>
<tr><td>None</td><td></td></tr>
<tr><td>AllowUpdate</td><td></td></tr>
<tr><td>AllowCompaction</td><td></td></tr>
<tr><td>PreferFastTrace</td><td></td></tr>
<tr><td>PreferFastBuild</td><td></td></tr>
<tr><td>MinimizeMemory</td><td></td></tr>
</table>
<br/>

<b>GGUserFile_CameraJitterType : The sequence of the jittered projection matrix</b><br/><br/>
<table>
<tr><th colspan=2>GGUserFile_CameraJitterType</th></tr>
<tr><td>None</td><td>No Jitter</td></tr>
<tr><td>UniformWhite</td><td>Uniform white noise</td></tr>
<tr><td>Halton23</td><td>Halton(2,3)</td></tr>
</table>
<br/>

<b>GigiCompileResult : </b><br/><br/>
<table>
<tr><th colspan=2>GigiCompileResult</th></tr>
<tr><td>OK</td><td></td></tr>
<tr><td>WrongVersion</td><td></td></tr>
<tr><td>WrongParams</td><td></td></tr>
<tr><td>CantLoadRenderGraph</td><td></td></tr>
<tr><td>ShaderAsserts</td><td></td></tr>
<tr><td>ShaderReflection</td><td></td></tr>
<tr><td>Validation</td><td></td></tr>
<tr><td>ReferenceFixup</td><td></td></tr>
<tr><td>DepluralizeFileCopies</td><td></td></tr>
<tr><td>NoBackend</td><td></td></tr>
<tr><td>BackendData</td><td></td></tr>
<tr><td>Sanitize</td><td></td></tr>
<tr><td>NotCompiledYet</td><td></td></tr>
<tr><td>InterpreterError</td><td></td></tr>
<tr><td>InlineSubGraphs</td><td></td></tr>
<tr><td>ErrorCheck</td><td></td></tr>
<tr><td>ShaderFileDuplication</td><td></td></tr>
<tr><td>AddNodeInfoToShaders</td><td></td></tr>
<tr><td>DataFixup</td><td></td></tr>
<tr><td>DfltFixup</td><td></td></tr>
<tr><td>HandleOutputsToMultiInput</td><td></td></tr>
</table>
<br/>

<b>GigiCompileWarning : Gigi compilation warnings</b><br/><br/>
<table>
<tr><th colspan=2>GigiCompileWarning</th></tr>
<tr><td>ShaderUnusedResource</td><td>A declared resource does not appear to be used in a shader. This can lead to additional transitions and unnecessary ordering constraints.</td></tr>
<tr><td>Count</td><td></td></tr>
</table>
<br/>

<b>DXShaderCompiler : Which directx shader compiler to use</b><br/><br/>
<table>
<tr><th colspan=2>DXShaderCompiler</th></tr>
<tr><td>FXC</td><td>The old shader compilation path.</td></tr>
<tr><td>DXC</td><td>The newer shader compilation path, required for raytracing.</td></tr>
</table>
<br/>

<b>FileCopyType : </b><br/><br/>
<table>
<tr><th colspan=2>FileCopyType</th></tr>
<tr><td>Private</td><td>Provided as input by the host application</td></tr>
<tr><td>Shader</td><td>Used internally to the technique only</td></tr>
<tr><td>Asset</td><td>An asset used by the technique</td></tr>
<tr><td>Count</td><td></td></tr>
</table>
<br/>

<b>SetVariableOperator : </b><br/><br/>
<table>
<tr><th colspan=2>SetVariableOperator</th></tr>
<tr><td>Add</td><td>+</td></tr>
<tr><td>Subtract</td><td>-</td></tr>
<tr><td>Multiply</td><td>*</td></tr>
<tr><td>Divide</td><td>/</td></tr>
<tr><td>Modulo</td><td>%</td></tr>
<tr><td>PowerOf2GE</td><td>The next power of two, greater or equal to the current value</td></tr>
<tr><td>Minimum</td><td>min(A,B)</td></tr>
<tr><td>Maximum</td><td>max(A,B)</td></tr>
<tr><td>BitwiseOr</td><td>A | B</td></tr>
<tr><td>BitwiseAnd</td><td>A & B</td></tr>
<tr><td>BitwiseXor</td><td>A ^ B</td></tr>
<tr><td>BitwiseNot</td><td>~A</td></tr>
<tr><td>Noop</td><td>Dont do anything, returns the left value</td></tr>
</table>
<br/>

<h1>Structs</h1>
Italicized fields are not serialized, and are just used for runtime storage.<br/>
<br/>
<b>BackendRestriction : Allows restriction to specific backends</b><br/><br/>
<table>
<tr><th colspan=3>BackendRestriction</th></tr>
<tr><td>Backend backends[]</td><td></td><td>A list of backends supported. Empty list means all backends</td></tr>
<tr><td>bool isWhiteList</td><td>true</td><td>If true, this is a list of allowed platforms. if false, it's a list of disallowed platforms.</td></tr>
<tr><td><i>unsigned int backendFlags</i></td><td>0</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>VariableReference : A reference to a variable</b><br/><br/>
<table>
<tr><th colspan=3>VariableReference</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the variable.</td></tr>
<tr><td><i>int variableIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>VariableReferenceNoConst : A reference to a variable. No const variables allowed.</b><br/><br/>
<table>
<tr><th colspan=3>VariableReferenceNoConst</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the variable.</td></tr>
<tr><td><i>int variableIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>VariableReferenceConstOnly : A reference to a variable. Only const variables allowed.</b><br/><br/>
<table>
<tr><th colspan=3>VariableReferenceConstOnly</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the variable.</td></tr>
<tr><td><i>int variableIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>StructReference : A reference to a struct</b><br/><br/>
<table>
<tr><th colspan=3>StructReference</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the struct.</td></tr>
<tr><td><i>int structIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>ComputeShaderReference : A reference to a shader</b><br/><br/>
<table>
<tr><th colspan=3>ComputeShaderReference</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader</td></tr>
<tr><td><i>int shaderIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>struct Shader* shader</i></td><td>nullptr</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>RayGenShaderReference : A reference to a ray gen shader</b><br/><br/>
<table>
<tr><th colspan=3>RayGenShaderReference</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader</td></tr>
<tr><td><i>int shaderIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>struct Shader* shader</i></td><td>nullptr</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>RTClosestHitShaderReference : A reference to a RTClosestHit shader</b><br/><br/>
<table>
<tr><th colspan=3>RTClosestHitShaderReference</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader</td></tr>
<tr><td><i>int shaderIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>struct Shader* shader</i></td><td>nullptr</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>RTClosestHitShaderReferenceOptional : Optional version</b><br/><br/>
<table>
<tr><th colspan=3>RTClosestHitShaderReferenceOptional</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader</td></tr>
<tr><td><i>int shaderIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>struct Shader* shader</i></td><td>nullptr</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>RTAnyHitShaderReference : A reference to RTAnyHit shader</b><br/><br/>
<table>
<tr><th colspan=3>RTAnyHitShaderReference</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader</td></tr>
<tr><td><i>int shaderIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>struct Shader* shader</i></td><td>nullptr</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>RTAnyHitShaderReferenceOptional : Optional version</b><br/><br/>
<table>
<tr><th colspan=3>RTAnyHitShaderReferenceOptional</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader</td></tr>
<tr><td><i>int shaderIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>struct Shader* shader</i></td><td>nullptr</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>RTIntersectionShaderReference : A reference to an RTIntersection shader</b><br/><br/>
<table>
<tr><th colspan=3>RTIntersectionShaderReference</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader</td></tr>
<tr><td><i>int shaderIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>struct Shader* shader</i></td><td>nullptr</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>RTIntersectionShaderReferenceOptional : Optional version</b><br/><br/>
<table>
<tr><th colspan=3>RTIntersectionShaderReferenceOptional</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader</td></tr>
<tr><td><i>int shaderIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>struct Shader* shader</i></td><td>nullptr</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>VertexShaderReference : A reference to a vertex shader</b><br/><br/>
<table>
<tr><th colspan=3>VertexShaderReference</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader</td></tr>
<tr><td><i>int shaderIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>struct Shader* shader</i></td><td>nullptr</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>PixelShaderReference : A reference to a pixel shader</b><br/><br/>
<table>
<tr><th colspan=3>PixelShaderReference</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader</td></tr>
<tr><td><i>int shaderIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>struct Shader* shader</i></td><td>nullptr</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>AmplificationShaderReference : A reference to an amplification shader</b><br/><br/>
<table>
<tr><th colspan=3>AmplificationShaderReference</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader</td></tr>
<tr><td><i>int shaderIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>struct Shader* shader</i></td><td>nullptr</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>MeshShaderReference : A reference to a mesh shader</b><br/><br/>
<table>
<tr><th colspan=3>MeshShaderReference</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader</td></tr>
<tr><td><i>int shaderIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>struct Shader* shader</i></td><td>nullptr</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>VertexShaderReferenceOptional : An optional reference to a vertex shader</b><br/><br/>
<table>
<tr><th colspan=3>VertexShaderReferenceOptional</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader</td></tr>
<tr><td><i>int shaderIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>struct Shader* shader</i></td><td>nullptr</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>PixelShaderReferenceOptional : An optional reference to a pixel shader</b><br/><br/>
<table>
<tr><th colspan=3>PixelShaderReferenceOptional</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader</td></tr>
<tr><td><i>int shaderIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>struct Shader* shader</i></td><td>nullptr</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>AmplificationShaderReferenceOptional : An optional reference to an amplification shader</b><br/><br/>
<table>
<tr><th colspan=3>AmplificationShaderReferenceOptional</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader</td></tr>
<tr><td><i>int shaderIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>struct Shader* shader</i></td><td>nullptr</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>MeshShaderReferenceOptional : An optional reference to a mesh shader</b><br/><br/>
<table>
<tr><th colspan=3>MeshShaderReferenceOptional</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader</td></tr>
<tr><td><i>int shaderIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>struct Shader* shader</i></td><td>nullptr</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>StructField : A field in a struct</b><br/><br/>
<table>
<tr><th colspan=3>StructField</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the field</td></tr>
<tr><td>DataFieldType type</td><td>DataFieldType::Count</td><td>The type of the field</td></tr>
<tr><td>std::string dflt</td><td>""</td><td>The default value</td></tr>
<tr><td>std::string comment</td><td>""</td><td>A comment to explain the field</td></tr>
<tr><td>std::string Enum</td><td>""</td><td>Integer types can specify an enum, which will then make symbols in both C++ and shader code.</td></tr>
<tr><td>StructFieldSemantic semantic</td><td>StructFieldSemantic::Count</td><td>Used to specify if the struct field has special meaning, such as a vertex position in a vertex buffer. If none is given, it shows up in shaders as an autonumbering text coordinate.</td></tr>
<tr><td>int semanticIndex</td><td>0</td><td>Some semantics can have multiple channels, like UVs and colors</td></tr>
<tr><td><i>int enumIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>size_t sizeInBytes</i></td><td>0</td><td>The size in bytes of this field</td></tr>
</table>
<br/>

<b>Struct : A description of a struct</b><br/><br/>
<table>
<tr><th colspan=3>Struct</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the struct.</td></tr>
<tr><td>bool forceHostVisible</td><td>false</td><td>If true, the struct will be visible to the host, even if the struct isn't used by anything host visible.</td></tr>
<tr><td>StructField fields[]</td><td></td><td>The data fields</td></tr>
<tr><td><i>size_t sizeInBytes</i></td><td>0</td><td>The size in bytes of this struct</td></tr>
<tr><td><i>bool exported</i></td><td>false</td><td>If true, will be visible to the host app</td></tr>
<tr><td>std::string definition</td><td>""</td><td>The parsed string definition of the struct.</td></tr>
<tr><td><i>std::string originalName</i></td><td>""</td><td>The name before renames and sanitization</td></tr>
<tr><td><i>std::string scope</i></td><td>""</td><td>The scope that the node lives in. A possibly nested list of subgraph node names, seperated by a dot.</td></tr>
</table>
<br/>

<b>ShaderResourceBuffer : Data specific to buffers</b><br/><br/>
<table>
<tr><th colspan=3>ShaderResourceBuffer</th></tr>
<tr><td>DataFieldType type</td><td>DataFieldType::Count</td><td>The data type of the buffer if a simple type</td></tr>
<tr><td>StructReference typeStruct</td><td>{}</td><td>The data type of the buffer if a struct type</td></tr>
<tr><td>bool raw</td><td>false</td><td>If true, will be viewed raw in the shader (E.g. DX12 ByteAddressBuffer)</td></tr>
<tr><td>bool PODAsStructuredBuffer</td><td>true</td><td>Set this to true if you want it to be StructuredBuffer instead of a Buffer, for non structure typed buffers.</td></tr>
<tr><td>bool globallyCoherent</td><td>false</td><td>Set this to true if you want the resource to be declared as globallycoherent.</td></tr>
</table>
<br/>

<b>ShaderResourceTexture : Data specific to textures</b><br/><br/>
<table>
<tr><th colspan=3>ShaderResourceTexture</th></tr>
<tr><td>TextureDimensionType dimension</td><td>TextureDimensionType::Texture2D</td><td>The dimensionality of the texture</td></tr>
<tr><td>TextureViewType viewType</td><td>TextureViewType::Float4</td><td>The dimensionality of the texture</td></tr>
<tr><td>bool globallyCoherent</td><td>false</td><td>Set this to true if you want the resource to be declared as globallycoherent.</td></tr>
</table>
<br/>

<b>ShaderSampler : Data specific to samplers</b><br/><br/>
<table>
<tr><th colspan=3>ShaderSampler</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the resource in the shader</td></tr>
<tr><td>SamplerFilter filter</td><td>SamplerFilter::MinMagMipLinear</td><td>The type of filtering to do</td></tr>
<tr><td>SamplerAddressMode addressMode</td><td>SamplerAddressMode::Wrap</td><td>The sampling address mode</td></tr>
</table>
<br/>

<b>ShaderResource : A declaration of a resource that a shader wants</b><br/><br/>
<table>
<tr><th colspan=3>ShaderResource</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the resource in the shader</td></tr>
<tr><td>ShaderResourceType type</td><td>ShaderResourceType::Count</td><td>The resource type</td></tr>
<tr><td>ShaderResourceAccessType access</td><td>ShaderResourceAccessType::Count</td><td>How the resource is accessed</td></tr>
<tr><td>ShaderResourceBuffer buffer</td><td>{}</td><td>Data specific to buffers</td></tr>
<tr><td>ShaderResourceTexture texture</td><td>{}</td><td>Data specific to textures</td></tr>
<tr><td>BackendRestriction backends</td><td>{}</td><td>The backends this resource is present for.</td></tr>
<tr><td><i>int registerIndex</i></td><td>-1</td><td>For root signatures and shader code that wants registers declared. Calculated before backend code is called, for convenience of backends.</td></tr>
<tr><td><i>int constantBufferStructIndex</i></td><td>-1</td><td>for CBVs, this is the index in renderGraph.structs that describes the constant buffer</td></tr>
</table>
<br/>

<b>ShaderConstantBuffer : A reference to a struct</b><br/><br/>
<table>
<tr><th colspan=3>ShaderConstantBuffer</th></tr>
<tr><td>std::string resourceName</td><td>""</td><td>The name of the resource in the shader</td></tr>
<tr><td>std::string structName</td><td>""</td><td>The name of the struct used</td></tr>
<tr><td><i>int structIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>ShaderDefine : A shader define as part of shader compilation</b><br/><br/>
<table>
<tr><th colspan=3>ShaderDefine</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the define.</td></tr>
<tr><td>std::string value</td><td>""</td><td>The value of the define.</td></tr>
</table>
<br/>

<b>TokenReplacement : A shader token replacement</b><br/><br/>
<table>
<tr><th colspan=3>TokenReplacement</th></tr>
<tr><td>std::string name</td><td>""</td><td>The token string.</td></tr>
<tr><td>std::string value</td><td>""</td><td>The replacement.</td></tr>
</table>
<br/>

<b>LoadedTextureReference : Information about a loaded texture referenced by this shader.</b><br/><br/>
<table>
<tr><th colspan=3>LoadedTextureReference</th></tr>
<tr><td>std::string token</td><td>""</td><td>The token as it appears in the shader.</td></tr>
<tr><td>std::string resourceName</td><td>""</td><td>The name of the resource to replace it with.</td></tr>
</table>
<br/>

<b>RTHitGroup : A declaration of a ray tracing hit group, which may contain a closest hit, any hit, and intersection shader</b><br/><br/>
<table>
<tr><th colspan=3>RTHitGroup</th></tr>
<tr><td>std::string name</td><td>""</td><td>The unique name of the hit group</td></tr>
<tr><td>RTClosestHitShaderReferenceOptional closestHit</td><td>{}</td><td>The closest hit shader</td></tr>
<tr><td>RTAnyHitShaderReferenceOptional anyHit</td><td>{}</td><td>The any hit shader</td></tr>
<tr><td>RTIntersectionShaderReferenceOptional intersection</td><td>{}</td><td>The intersection shader</td></tr>
<tr><td><i>std::string originalName</i></td><td>""</td><td>The name before renames and sanitization</td></tr>
<tr><td><i>std::string scope</i></td><td>""</td><td>The scope that the node lives in. A possibly nested list of subgraph node names, seperated by a dot.</td></tr>
</table>
<br/>

<b>SlangOptions : A declaration of a shader</b><br/><br/>
<table>
<tr><th colspan=3>SlangOptions</th></tr>
<tr><td>bool process</td><td>false</td><td>if true, this shader will be processed by slang</td></tr>
</table>
<br/>

<b>Shader : A declaration of a shader</b><br/><br/>
<table>
<tr><th colspan=3>Shader</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the shader, as it will be referenced by nodes</td></tr>
<tr><td>std::string fileName</td><td>""</td><td>The file name of the shader file.</td></tr>
<tr><td><i>std::string destFileName</i></td><td>""</td><td>Filled out by compiler.  Where the shader file is supposed to go after compilation.</td></tr>
<tr><td>ShaderType type</td><td>ShaderType::Compute</td><td>The type of shader it is</td></tr>
<tr><td>std::string entryPoint</td><td>""</td><td>The shader entrypoint.</td></tr>
<tr><td>ShaderDefine defines[]</td><td></td><td>The defines the shader is compiled with.</td></tr>
<tr><td><i>TokenReplacement tokenReplacements[]</i></td><td></td><td>The token replacements specific for the shader.</td></tr>
<tr><td>int CSNumThreads[3]</td><td>{ 8 , 8 , 1 }</td><td>For compute shaders only, the number of threads each dispatch has. 61,1,1 suggested for 1d. 8,8,1 for 2d. 4,4,4 for 3d.</td></tr>
<tr><td>int NumThreads[3]</td><td>{ 8 , 8 , 1 }</td><td>The number of threads each dispatch has, for applicable shader types. 64,1,1 suggested for 1d. 8,8,1 for 2d. 4,4,4 for 3d.</td></tr>
<tr><td>bool copyFile</td><td>true</td><td>if false, will not copy the file over. A hackaround for when you have multiple raytracing shaders in the same file. TODO: resolve this better.</td></tr>
<tr><td>SlangOptions slangOptions</td><td>{}</td><td>Settings for optionally processing shaders with slang</td></tr>
<tr><td>BackendRestriction backends</td><td>{}</td><td>The backends this file copy happens for.</td></tr>
<tr><td>ShaderResource resources[]</td><td></td><td>SRVs, UAVs etc. that the shader wants to access. Generates code into the shader for their declarations.</td></tr>
<tr><td>ShaderSampler samplers[]</td><td></td><td>SRVs, UAVs etc. that the shader wants to access. Generates code into the shader for their declarations.</td></tr>
<tr><td>ShaderConstantBuffer constantBuffers[]</td><td></td><td>A list of constant buffers this shader wants.</td></tr>
<tr><td><i>std::vector<LoadedTextureReference> loadedTextureRefs</i></td><td>{}</td><td>The list of loaded textures this shader references.</td></tr>
<tr><td><i>std::wstring entryPointW</i></td><td>L""</td><td>The wide string version of the entry point. Made for convinience.</td></tr>
<tr><td><i>std::string originalName</i></td><td>""</td><td>The name before renames and sanitization</td></tr>
<tr><td><i>std::string scope</i></td><td>""</td><td>The scope that the node lives in. A possibly nested list of subgraph node names, seperated by a dot.</td></tr>
<tr><td><i>std::string Used_RTHitGroupIndex[]</i></td><td></td><td>All RTHitGroupIndex names used in the shader</td></tr>
<tr><td><i>std::string Used_RTMissIndex[]</i></td><td></td><td>All RTMissIndex names used in the shader</td></tr>
</table>
<br/>

<b>VariableUISettings : UI information for variables</b><br/><br/>
<table>
<tr><th colspan=3>VariableUISettings</th></tr>
<tr><td>VariableUIHint UIHint</td><td>VariableUIHint::Count</td><td>Any hints for UI</td></tr>
<tr><td>std::string min</td><td>""</td><td>The minimum value of the variable. Leave blank for no minimum.</td></tr>
<tr><td>std::string max</td><td>""</td><td>The maximum value of the variable. Leave blank for no maximum.</td></tr>
<tr><td>std::string step</td><td>""</td><td>The step size of the variable. Leave blank for default step size.</td></tr>
</table>
<br/>

<b>Variable : A variable definition</b><br/><br/>
<table>
<tr><th colspan=3>Variable</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the variable.</td></tr>
<tr><td>std::string comment</td><td>""</td><td>A comment for the variable.</td></tr>
<tr><td>DataFieldType type</td><td>DataFieldType::Count</td><td>The type of the variable</td></tr>
<tr><td>bool Const</td><td>false</td><td>If true, the variable is declared const and cannot change at runtime</td></tr>
<tr><td>bool Static</td><td>false</td><td>If true, the variable has the same value for all instances of the technique</td></tr>
<tr><td>std::string dflt</td><td>""</td><td>The default value of the variable. The default memory is zero initialized before this is parsed, so if you don't give it enough initializers, it will use zero for the unlisted fields.</td></tr>
<tr><td>VariableVisibility visibility</td><td>VariableVisibility::Internal</td><td>Who can see and interact with this variable</td></tr>
<tr><td>std::string Enum</td><td>""</td><td>Integer types can specify an enum, which will then make symbols in both C++ and shader code.</td></tr>
<tr><td>BackendRestriction backends</td><td>{}</td><td>This variable can be limited to specific backends</td></tr>
<tr><td>bool transient</td><td>false</td><td>If true, the variable should not be saved between runs of this technique. The Gigi viewer uses this to decide if it should save it in the gguser file or not, for example.</td></tr>
<tr><td>VariableUISettings UISettings</td><td>{}</td><td>UI Settings.</td></tr>
<tr><td>std::string UIGroup</td><td>""</td><td>Used to organize variables into folders in the viewer. separate folders with dots.  For instance: settings.controls</td></tr>
<tr><td><i>int enumIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>std::string originalName</i></td><td>""</td><td>The name before renames and sanitization</td></tr>
<tr><td><i>std::string scope</i></td><td>""</td><td>The scope that the node lives in. A possibly nested list of subgraph node names, seperated by a dot.</td></tr>
<tr><td>VariableUIHint UIHint</td><td>VariableUIHint::Count</td><td>Any hints for UI</td></tr>
</table>
<br/>

<b>Condition : Specifiy a condition to make something conditional</b><br/><br/>
<table>
<tr><th colspan=3>Condition</th></tr>
<tr><td>std::string variable1</td><td>{}</td><td>Value 1</td></tr>
<tr><td>ConditionComparison comparison</td><td>ConditionComparison::Count</td><td>The comparison operator</td></tr>
<tr><td>std::string value2</td><td>{}</td><td>Value 2</td></tr>
<tr><td>std::string variable2</td><td>{}</td><td>Value 2</td></tr>
<tr><td><i>int variable1Index</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>int variable2Index</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td>bool alwaysFalse</td><td>false</td><td>If checked, condition always evaluates to false</td></tr>
</table>
<br/>

<b>EnumItem : Specifiy an enum</b><br/><br/>
<table>
<tr><th colspan=3>EnumItem</th></tr>
<tr><td>std::string label</td><td>""</td><td>The text label of an enum</td></tr>
<tr><td><i>std::string displayLabel</i></td><td>""</td><td>name before sanitization</td></tr>
<tr><td>std::string comment</td><td>""</td><td></td></tr>
</table>
<br/>

<b>Enum : Specifiy an enum</b><br/><br/>
<table>
<tr><th colspan=3>Enum</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the enum</td></tr>
<tr><td>EnumItem items[]</td><td></td><td>The items in the enum. Values start at 0 and count up from there.</td></tr>
<tr><td>std::string comment</td><td>""</td><td></td></tr>
<tr><td><i>std::string originalName</i></td><td>""</td><td>The name before renames and sanitization</td></tr>
<tr><td><i>std::string scope</i></td><td>""</td><td>The scope that the node lives in. A possibly nested list of subgraph node names, seperated by a dot.</td></tr>
</table>
<br/>

<b>NodeReference : A generic node reference</b><br/><br/>
<table>
<tr><th colspan=3>NodeReference</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the node</td></tr>
<tr><td><i>int nodeIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>TextureNodeReference : A texture node reference</b><br/><br/>
<table>
<tr><th colspan=3>TextureNodeReference - Inherits from NodeReference</th></tr>
<tr><td><i>struct RenderGraphNode_Resource_Texture* textureNode</i></td><td>nullptr</td><td>A pointer to the texture node</td></tr>
</table>
<br/>

<b>BufferNodeReference : A buffer node reference</b><br/><br/>
<table>
<tr><th colspan=3>BufferNodeReference - Inherits from NodeReference</th></tr>
<tr><td><i>struct RenderGraphNode_Resource_Buffer* bufferNode</i></td><td>nullptr</td><td>A pointer to the buffer node</td></tr>
</table>
<br/>

<b>TextureOrBufferNodeReference : A texture or buffer node reference</b><br/><br/>
<table>
<tr><th colspan=3>TextureOrBufferNodeReference - Inherits from NodeReference</th></tr>
<tr><td><i>struct RenderGraphNode_Resource_Texture* textureNode</i></td><td>nullptr</td><td>A pointer to the texture node</td></tr>
<tr><td><i>struct RenderGraphNode_Resource_Buffer* bufferNode</i></td><td>nullptr</td><td>A pointer to the texture node</td></tr>
</table>
<br/>

<b>NodePinReference : A reference to a pin on a node</b><br/><br/>
<table>
<tr><th colspan=3>NodePinReference</th></tr>
<tr><td>std::string node</td><td>""</td><td>The name of the node</td></tr>
<tr><td>std::string pin</td><td>""</td><td>The name of the pin</td></tr>
<tr><td><i>int nodeIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>int nodePinIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>int resourceNodeIndex</i></td><td>-1</td><td>Calculated for convenience. The resource node ultimately plugged into this pin.</td></tr>
</table>
<br/>

<b>NodePinReferenceOptional : A reference to a pin on a node</b><br/><br/>
<table>
<tr><th colspan=3>NodePinReferenceOptional</th></tr>
<tr><td>std::string node</td><td>""</td><td>The name of the node</td></tr>
<tr><td>std::string pin</td><td>""</td><td>The name of the pin</td></tr>
<tr><td><i>int nodeIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>int nodePinIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>int resourceNodeIndex</i></td><td>-1</td><td>Calculated for convenience. The resource node ultimately plugged into this pin.</td></tr>
</table>
<br/>

<b>NodePinConnection : A connection from a node to another node</b><br/><br/>
<table>
<tr><th colspan=3>NodePinConnection</th></tr>
<tr><td>std::string srcPin</td><td>""</td><td>The name of this pin</td></tr>
<tr><td>std::string dstNode</td><td>""</td><td>The name of the node</td></tr>
<tr><td>std::string dstPin</td><td>""</td><td>The name of the pin</td></tr>
<tr><td>BackendRestriction backends</td><td>{}</td><td>The backends this connection is present for.</td></tr>
<tr><td><i>int srcNodePinIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>int dstNodeIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
<tr><td><i>int dstNodePinIndex</i></td><td>-1</td><td>Calculated for convenience.</td></tr>
</table>
<br/>

<b>TextureSizeDesc : size = (inputSize + preAdd) * multiply / divide + postAdd.  inputSize is (1,1,1) if nothing given.</b><br/><br/>
<table>
<tr><th colspan=3>TextureSizeDesc</th></tr>
<tr><td>TextureNodeReference node</td><td>{}</td><td>The node referenced, if there is one.</td></tr>
<tr><td>VariableReference variable</td><td>{}</td><td>If a variable is given, the size will be based on the value of the variable</td></tr>
<tr><td>int multiply[3]</td><td>{ 1 , 1 , 1 }</td><td></td></tr>
<tr><td>int divide[3]</td><td>{ 1 , 1 , 1 }</td><td></td></tr>
<tr><td>int preAdd[3]</td><td>{ 0 , 0 , 0 }</td><td></td></tr>
<tr><td>int postAdd[3]</td><td>{ 0 , 0 , 0 }</td><td></td></tr>
</table>
<br/>

<b>DispatchSizeDesc : The number of threads to dispatch. Not thread groups.  size = (inputSize + preAdd) * multiply / divide + postAdd.  inputSize is (1,1,1) if nothing given.</b><br/><br/>
<table>
<tr><th colspan=3>DispatchSizeDesc</th></tr>
<tr><td>TextureOrBufferNodeReference node</td><td>{}</td><td>If a texture or buffer is specified, the dispatch size will be based on the size of the texture or buffer</td></tr>
<tr><td>VariableReference variable</td><td>{}</td><td>If a variable is given, the dispatch size will be based on the value of the variable</td></tr>
<tr><td>NodePinReferenceOptional indirectBuffer</td><td>{}</td><td>If given, this buffer will be used as an indirect dispatch buffer</td></tr>
<tr><td>int multiply[3]</td><td>{ 1 , 1 , 1 }</td><td></td></tr>
<tr><td>int divide[3]</td><td>{ 1 , 1 , 1 }</td><td></td></tr>
<tr><td>int preAdd[3]</td><td>{ 0 , 0 , 0 }</td><td></td></tr>
<tr><td>int postAdd[3]</td><td>{ 0 , 0 , 0 }</td><td></td></tr>
<tr><td>VariableReference indirectOffsetVariable</td><td>{}</td><td>If a variable is given, it will be used as the offset into the indirect dispatch buffer. 0 would be the start of the buffer, 1 would start at the 4th value in the buffer, and so on.</td></tr>
<tr><td>int indirectOffsetValue</td><td>0</td><td>The offset into the indirect dispatch buffer if no variable given.  0 would be the start of the buffer, 1 would start at the 4th value in the buffer, and so on.</td></tr>
</table>
<br/>

<b>RayDispatchSizeDesc : size = (inputSize + preAdd) * multiply / divide + postAdd.  inputSize is (1,1,1) if nothing given.</b><br/><br/>
<table>
<tr><th colspan=3>RayDispatchSizeDesc</th></tr>
<tr><td>TextureOrBufferNodeReference node</td><td>{}</td><td>If a texture or buffer is specified, the dispatch size will be based on the size of the texture or buffer</td></tr>
<tr><td>VariableReference variable</td><td>{}</td><td>If a variable is given, the dispatch size will be based on the value of the variable</td></tr>
<tr><td>int multiply[3]</td><td>{ 1 , 1 , 1 }</td><td></td></tr>
<tr><td>int divide[3]</td><td>{ 1 , 1 , 1 }</td><td></td></tr>
<tr><td>int preAdd[3]</td><td>{ 0 , 0 , 0 }</td><td></td></tr>
<tr><td>int postAdd[3]</td><td>{ 0 , 0 , 0 }</td><td></td></tr>
</table>
<br/>

<b>BufferCountDesc : count = (inputCount + preAdd) * multiply / divide + postAdd.  inputCount is 1 if nothing given.</b><br/><br/>
<table>
<tr><th colspan=3>BufferCountDesc</th></tr>
<tr><td>BufferNodeReference node</td><td>{}</td><td>The node referenced, if there is one.</td></tr>
<tr><td>VariableReference variable</td><td>{}</td><td>The variable referenced, if there is one.</td></tr>
<tr><td>int multiply</td><td>1</td><td></td></tr>
<tr><td>int divide</td><td>1</td><td></td></tr>
<tr><td>int preAdd</td><td>0</td><td></td></tr>
<tr><td>int postAdd</td><td>0</td><td></td></tr>
</table>
<br/>

<b>TextureFormatDesc : Specifies a texture format</b><br/><br/>
<table>
<tr><th colspan=3>TextureFormatDesc</th></tr>
<tr><td>TextureNodeReference node</td><td>{}</td><td>This node's format is used, if specified</td></tr>
<tr><td>TextureFormat format</td><td>TextureFormat::Any</td><td>A specific format can be specified</td></tr>
<tr><td>VariableReference variable</td><td>{}</td><td>The variable that holds the texture format. Assumed to be a uint32.</td></tr>
</table>
<br/>

<b>BufferFormatDesc : Specifies a buffer format</b><br/><br/>
<table>
<tr><th colspan=3>BufferFormatDesc</th></tr>
<tr><td>BufferNodeReference node</td><td>{}</td><td>This node's format is used, if specified</td></tr>
<tr><td>StructReference structureType</td><td>{}</td><td>The buffer type, if it is a structured buffer</td></tr>
<tr><td>DataFieldType type</td><td>DataFieldType::Count</td><td>The buffer type. May become a typed or structured buffer, depending on the type chosen.</td></tr>
</table>
<br/>

<b>ResourceDependency : Specifies a resource dependency</b><br/><br/>
<table>
<tr><th colspan=3>ResourceDependency</th></tr>
<tr><td><i>int nodeIndex</i></td><td>-1</td><td>The index of the resource node.</td></tr>
<tr><td><i>int pinIndex</i></td><td>-1</td><td>The pin index of this action node</td></tr>
<tr><td><i>ShaderResourceAccessType access</i></td><td>ShaderResourceAccessType::Count</td><td>How the resource is accessed.</td></tr>
<tr><td><i>ShaderResourceType type</i></td><td>ShaderResourceType::Count</td><td>What type of resource it is.</td></tr>
</table>
<br/>

<b>SetCBFromVar : Specify that a structure field should be set to the value of a variable</b><br/><br/>
<table>
<tr><th colspan=3>SetCBFromVar</th></tr>
<tr><td>std::string field</td><td>""</td><td>The name of the field to set</td></tr>
<tr><td>VariableReference variable</td><td>{}</td><td>The name of the variable to take the value from</td></tr>
</table>
<br/>

<b>ColorTargetSettings : Settings for a color target in a draw call</b><br/><br/>
<table>
<tr><th colspan=3>ColorTargetSettings</th></tr>
<tr><td>bool clear</td><td>false</td><td>If true, clears the color target before drawing</td></tr>
<tr><td>float clearColor[4]</td><td>{ 1.0f , 1.0f , 1.0f , 1.0f}</td><td>The color to clear the render target</td></tr>
<tr><td>bool writeChannels[4]</td><td>{ true , true , true , true }</td><td>Controls whether R,G,B,A get written or not</td></tr>
<tr><td>bool enableBlending</td><td>false</td><td>Enables alpha blending</td></tr>
<tr><td>DrawBlendMode srcBlend</td><td>DrawBlendMode::One</td><td></td></tr>
<tr><td>DrawBlendMode destBlend</td><td>DrawBlendMode::Zero</td><td></td></tr>
<tr><td>DrawBlendMode srcBlendAlpha</td><td>DrawBlendMode::One</td><td></td></tr>
<tr><td>DrawBlendMode destBlendAlpha</td><td>DrawBlendMode::Zero</td><td></td></tr>
<tr><td>int arrayIndex</td><td>0</td><td>The array index, for Texture2DArray, Texture3D etc</td></tr>
<tr><td>int mipLevel</td><td>0</td><td>The mip to use</td></tr>
</table>
<br/>

<b>SubgraphDataVariable : Variables in the subgraph</b><br/><br/>
<table>
<tr><th colspan=3>SubgraphDataVariable</th></tr>
<tr><td>std::string name</td><td>""</td><td>variable name</td></tr>
<tr><td>VariableVisibility visibility</td><td>VariableVisibility::Internal</td><td>Who can see and interact with this variable</td></tr>
</table>
<br/>

<b>SubGraphData : Cached data about a subgraph</b><br/><br/>
<table>
<tr><th colspan=3>SubGraphData</th></tr>
<tr><td>std::string importedResources[]</td><td></td><td>input output pins</td></tr>
<tr><td>std::string exportedResources[]</td><td></td><td>output only pins</td></tr>
<tr><td>SubgraphDataVariable variables[]</td><td></td><td>Variables in the subgraph</td></tr>
</table>
<br/>

<b>SubGraphVariableSettings : Cached data about a subgraph</b><br/><br/>
<table>
<tr><th colspan=3>SubGraphVariableSettings</th></tr>
<tr><td>std::string name</td><td>""</td><td>variable name</td></tr>
<tr><td>VariableVisibility visibility</td><td>VariableVisibility::Internal</td><td>Who can see and interact with this variable</td></tr>
<tr><td>std::string replaceWithStr</td><td>{}</td><td>If set, the subgraph variable will be deleted and all references will use this parent graph variable instead.</td></tr>
<tr><td>std::string replaceWithValue</td><td>{}</td><td>Replace the variable with a literal value. At gigi compile time it makes an internal private variable of the correct type with this string as the default value.</td></tr>
<tr><td>bool isLoopIndex</td><td>false</td><td>If true, this variable will recieve the loop index.</td></tr>
<tr><td>VariableReference replaceWith</td><td>{}</td><td>If set, the subgraph variable will be deleted and all references will use this parent graph variable instead.</td></tr>
</table>
<br/>

<b>LinkProperties : Properties of links between nodes.</b><br/><br/>
<table>
<tr><th colspan=3>LinkProperties</th></tr>
<tr><td>int UAVMipIndex</td><td>0</td><td>The mip index to use, if this is a UAV connection.</td></tr>
</table>
<br/>

<b>RenderGraphNode_Base : The base type of all node types</b><br/><br/>
<table>
<tr><th colspan=3>RenderGraphNode_Base</th></tr>
<tr><td>std::string name</td><td>""</td><td>The name of the node</td></tr>
<tr><td>BackendRestriction backends</td><td>{}</td><td>This node can be limited to specific backends</td></tr>
<tr><td>std::string comment</td><td>""</td><td>A comment about the node which can appear in generated code</td></tr>
<tr><td>float editorPos[2]</td><td>{ 0.0f , 0.0f }</td><td>The position of the node in the editor</td></tr>
<tr><td><i>std::unordered_map<std::string COMMA int> inputPinIds</i></td><td>{}</td><td></td></tr>
<tr><td><i>std::unordered_map<std::string COMMA int> outputPinIds</i></td><td>{}</td><td></td></tr>
<tr><td><i>int nodeIndex</i></td><td>-1</td><td>The index in the list of render graph nodes. This is filled in after loading by the ReferenceFixupVisitor and is in [0,N) with no gaps.</td></tr>
<tr><td><i>std::string originalName</i></td><td>""</td><td>The name before renames and sanitization</td></tr>
</table>
<br/>

<b>RenderGraphNode_ResourceBase : The base type for resource node types</b><br/><br/>
<table>
<tr><th colspan=3>RenderGraphNode_ResourceBase - Inherits from RenderGraphNode_Base</th></tr>
<tr><td>bool transient</td><td>true</td><td>A non transient resource will persist across executions and frames. A transient resource may not, and is decided by the backend as a potential optimization opportunity.</td></tr>
<tr><td><b>inline static const bool c_isResourceNode</b></td><td>true</td><td>Whether or not this is a resource node.</td></tr>
<tr><td><i>ShaderResourceAccessType startingState</i></td><td>ShaderResourceAccessType::Count</td><td>The first state that a reosurce is in. Calculated for convenience.</td></tr>
<tr><td><i>ShaderResourceAccessType finalState</i></td><td>ShaderResourceAccessType::Count</td><td>The last state that a reosurce is in. Calculated for convenience.</td></tr>
<tr><td><i>unsigned int accessedAs</i></td><td>0</td><td>A bitfield of all the ways this resource is accessed (ShaderResourceAccessType). Useful for creating resources with the correct usage flags.</td></tr>
</table>
<br/>

<b>RenderGraphNode_ActionBase : The base type for action node types</b><br/><br/>
<table>
<tr><th colspan=3>RenderGraphNode_ActionBase - Inherits from RenderGraphNode_Base</th></tr>
<tr><td><b>inline static const bool c_isResourceNode</b></td><td>false</td><td>Whether or not this is a resource node.</td></tr>
<tr><td><i>ResourceDependency resourceDependencies[]</i></td><td></td><td>Filled in before backend code is called.</td></tr>
<tr><td>Condition condition</td><td>{}</td><td>An optional condition added for the action to happen</td></tr>
<tr><td>LinkProperties linkProperties[]</td><td></td><td>Specify array index / mip level for each pin. Should be same size and order as GetNodePins family of functons.</td></tr>
<tr><td>NodePinConnection connections[]</td><td></td><td>What is plugged into the pins</td></tr>
</table>
<br/>

<b>RenderGraphNode_Resource_Buffer : Declares a buffer</b><br/><br/>
<table>
<tr><th colspan=3>RenderGraphNode_Resource_Buffer - Inherits from RenderGraphNode_ResourceBase</th></tr>
<tr><td><b>inline static const std::string c_editorName</b></td><td>"Buffer"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shortTypeName</b></td><td>"Buffer"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shorterTypeName</b></td><td>"Buff"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const bool c_showInEditor</b></td><td>true</td><td>Used by the editor.</td></tr>
<tr><td>ResourceVisibility visibility</td><td>ResourceVisibility::Internal</td><td>Who can see the buffer and who owns it</td></tr>
<tr><td>BufferFormatDesc format</td><td>{}</td><td>The format of the texture.</td></tr>
<tr><td>BufferCountDesc count</td><td>{}</td><td>How many items are in the buffer.</td></tr>
</table>
<br/>

<b>RenderGraphNode_Resource_ShaderConstants : Declares a shader constant buffer</b><br/><br/>
<table>
<tr><th colspan=3>RenderGraphNode_Resource_ShaderConstants - Inherits from RenderGraphNode_ResourceBase</th></tr>
<tr><td><b>inline static const std::string c_editorName</b></td><td>"Constants"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shortTypeName</b></td><td>"Constants"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shorterTypeName</b></td><td>"Const"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const bool c_showInEditor</b></td><td>false</td><td>Used by the editor.</td></tr>
<tr><td>StructReference structure</td><td>{}</td><td>The structure of the constant buffer.</td></tr>
<tr><td>SetCBFromVar setFromVar[]</td><td></td><td>Set constant buffer (left) to the value of variable (right) every execution</td></tr>
</table>
<br/>

<b>RenderGraphNode_Resource_Texture : Declares a texture</b><br/><br/>
<table>
<tr><th colspan=3>RenderGraphNode_Resource_Texture - Inherits from RenderGraphNode_ResourceBase</th></tr>
<tr><td><b>inline static const std::string c_editorName</b></td><td>"Texture"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shortTypeName</b></td><td>"Texture"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shorterTypeName</b></td><td>"Tex"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const bool c_showInEditor</b></td><td>true</td><td>Used by the editor.</td></tr>
<tr><td>ResourceVisibility visibility</td><td>ResourceVisibility::Internal</td><td>Who can see the texture and who owns it</td></tr>
<tr><td>TextureFormatDesc format</td><td>{}</td><td>The format of the texture.</td></tr>
<tr><td>TextureSizeDesc size</td><td>{}</td><td>The size of the texture.</td></tr>
<tr><td>unsigned int numMips</td><td>1</td><td>The number of mips the texture should have. 0 means the full set. 1 means just the full size image, and no smaller mips.</td></tr>
<tr><td>TextureDimensionType dimension</td><td>TextureDimensionType::Texture2D</td><td>The dimensionality of the texture</td></tr>
<tr><td><i>std::string loadFileName</i></td><td>""</td><td>If not empty, it load it as an image. This is currently not exposed to users, and is created when shaders use an image token</td></tr>
<tr><td><i>bool loadFileNameAsSRGB</i></td><td>true</td><td>If true, the source file is treated as sRGB</td></tr>
</table>
<br/>

<b>RenderGraphNode_Action_ComputeShader : Executes a compute shader</b><br/><br/>
<table>
<tr><th colspan=3>RenderGraphNode_Action_ComputeShader - Inherits from RenderGraphNode_ActionBase</th></tr>
<tr><td><b>inline static const std::string c_editorName</b></td><td>"Compute Shader"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shortTypeName</b></td><td>"Compute"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shorterTypeName</b></td><td>"CS"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const bool c_showInEditor</b></td><td>true</td><td>Used by the editor.</td></tr>
<tr><td>ComputeShaderReference shader</td><td>{}</td><td>The shader.</td></tr>
<tr><td>DispatchSizeDesc dispatchSize</td><td>{}</td><td>The dispatch size.</td></tr>
<tr><td>std::string entryPoint</td><td>""</td><td>The shader entrypoint. Overrides the shader entry entryPoint.</td></tr>
<tr><td>ShaderDefine defines[]</td><td></td><td>The defines the shader is compiled with, on top of whatever defines the shader has already</td></tr>
</table>
<br/>

<b>RenderGraphNode_Action_RayShader : Executes a dispatch rays shader</b><br/><br/>
<table>
<tr><th colspan=3>RenderGraphNode_Action_RayShader - Inherits from RenderGraphNode_ActionBase</th></tr>
<tr><td><b>inline static const std::string c_editorName</b></td><td>"Ray Gen Shader"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shortTypeName</b></td><td>"RayGen"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shorterTypeName</b></td><td>"RGS"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const bool c_showInEditor</b></td><td>true</td><td>Used by the editor.</td></tr>
<tr><td>RayGenShaderReference shader</td><td>{}</td><td>The ray gen shader.</td></tr>
<tr><td>RayDispatchSizeDesc dispatchSize</td><td>{}</td><td>The dispatch size.</td></tr>
<tr><td>std::string entryPoint</td><td>""</td><td>The shader entrypoint. Overrides the shader entry entryPoint.</td></tr>
<tr><td>ShaderDefine defines[]</td><td></td><td>The defines the shader is compiled with, on top of whatever defines the shader has already</td></tr>
<tr><td>int maxRecursionDepth</td><td>3</td><td>The maximum recursion depth of the ray.</td></tr>
<tr><td>unsigned int rayPayloadSize</td><td>64</td><td>The size of the ray payload, in bytes. 64 bytes is four float4s.</td></tr>
</table>
<br/>

<b>RenderGraphNode_Action_CopyResource : Copies a resource to another resource</b><br/><br/>
<table>
<tr><th colspan=3>RenderGraphNode_Action_CopyResource - Inherits from RenderGraphNode_ActionBase</th></tr>
<tr><td><b>inline static const std::string c_editorName</b></td><td>"Copy Resource"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shortTypeName</b></td><td>"Copy"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shorterTypeName</b></td><td>"Copy"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const bool c_showInEditor</b></td><td>true</td><td>Used by the editor.</td></tr>
<tr><td>NodePinReference source</td><td>{}</td><td>The resource being copied from.</td></tr>
<tr><td>NodePinReference dest</td><td>{}</td><td>The resource being copied to.</td></tr>
</table>
<br/>

<b>RenderGraphNode_Action_DrawCall : Rasterization</b><br/><br/>
<table>
<tr><th colspan=3>RenderGraphNode_Action_DrawCall - Inherits from RenderGraphNode_ActionBase</th></tr>
<tr><td><b>inline static const std::string c_editorName</b></td><td>"Draw Call"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shortTypeName</b></td><td>"Draw"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shorterTypeName</b></td><td>"Draw"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const bool c_showInEditor</b></td><td>true</td><td>Used by the editor.</td></tr>
<tr><td>AmplificationShaderReferenceOptional amplificationShader</td><td>{}</td><td>The amplification shader.</td></tr>
<tr><td>MeshShaderReferenceOptional meshShader</td><td>{}</td><td>The mesh shader.</td></tr>
<tr><td>VertexShaderReferenceOptional vertexShader</td><td>{}</td><td>The vertex shader.</td></tr>
<tr><td>PixelShaderReference pixelShader</td><td>{}</td><td>The pixel shader.</td></tr>
<tr><td>int countPerInstance</td><td>-1</td><td>If using an index buffer, this is indexCountPerInstance, else is vertexCountPerInstance.  If -1, will use the count of the buffer.  Else, if a buffer is given, will use min(buffer count, countPerInstance).</td></tr>
<tr><td>int instanceCount</td><td>1</td><td>How many instances to draw. If -1, will use the count of the instance buffer. Else, if an instance buffer is given, will use min (instance buffer count, instanceCount).</td></tr>
<tr><td>DispatchSizeDesc meshShaderDispatchSize</td><td>{}</td><td>The mesh shader dispatch size.</td></tr>
<tr><td>bool depthTargetClear</td><td>false</td><td>If true, clears the depth target before doing a draw call.</td></tr>
<tr><td>float depthTargetClearValue</td><td>0.0f</td><td>The value to clear the depth target to.</td></tr>
<tr><td>bool depthWrite</td><td>true</td><td>If false, disables writing to the depth buffer</td></tr>
<tr><td>int depthArrayIndex</td><td>0</td><td>The array index, for Texture2DArray, Texture3D etc</td></tr>
<tr><td>int depthMipLevel</td><td>0</td><td>The mip to use</td></tr>
<tr><td>DepthTestFunction depthTest</td><td>DepthTestFunction::Less</td><td></td></tr>
<tr><td>bool stencilClear</td><td>false</td><td>If true, clears the stencil before doing a draw call.</td></tr>
<tr><td>uint8_t stencilClearValue</td><td>0</td><td></td></tr>
<tr><td>uint8_t stencilRef</td><td>0</td><td>Sets the reference value for depth stencil tests.</td></tr>
<tr><td>uint8_t stencilReadMask</td><td>255</td><td></td></tr>
<tr><td>uint8_t stencilWriteMask</td><td>255</td><td></td></tr>
<tr><td>StencilOp frontFaceStencilFail</td><td>StencilOp::Keep</td><td>When stencil test fails</td></tr>
<tr><td>StencilOp backFaceStencilFail</td><td>StencilOp::Keep</td><td>When stencil test fails</td></tr>
<tr><td>StencilOp frontFaceStencilDepthFail</td><td>StencilOp::Keep</td><td>When stencil passes but depth fails</td></tr>
<tr><td>StencilOp backFaceStencilDepthFail</td><td>StencilOp::Keep</td><td>When stencil passes but depth fails</td></tr>
<tr><td>StencilOp frontFaceStencilPass</td><td>StencilOp::Keep</td><td>When stencil and depth both pass</td></tr>
<tr><td>StencilOp backFaceStencilPass</td><td>StencilOp::Keep</td><td>When stencil and depth both pass</td></tr>
<tr><td>DepthTestFunction frontFaceStencilFunc</td><td>DepthTestFunction::Always</td><td>How to test stencil data against existing stencil data</td></tr>
<tr><td>DepthTestFunction backFaceStencilFunc</td><td>DepthTestFunction::Always</td><td>How to test stencil data against existing stencil data</td></tr>
<tr><td>bool conservativeRasterization</td><td>false</td><td>Turns on conservative rasterization</td></tr>
<tr><td>bool alphaAsCoverage</td><td>false</td><td>Turns on alpha as coverage</td></tr>
<tr><td>bool independentAlpha</td><td>false</td><td>If false, colorTargetSettings[0] defines blend mode for all color targets</td></tr>
<tr><td>ColorTargetSettings colorTargetSettings[8]</td><td>{}</td><td>Settings for the color targets</td></tr>
<tr><td>ShaderDefine defines[]</td><td></td><td>The defines the shaders ares compiled with, on top of whatever defines the shaders have already</td></tr>
<tr><td>DrawCullMode cullMode</td><td>DrawCullMode::None</td><td></td></tr>
<tr><td>bool frontIsCounterClockwise</td><td>true</td><td></td></tr>
<tr><td>ShadingRate shadingRate</td><td>ShadingRate::_1x1</td><td>For variable rate shading</td></tr>
<tr><td>ShadingRateCombiner shadingRateCombiner1</td><td>ShadingRateCombiner::PassThrough</td><td>For variable rate shading. This combines the provoking vertex shading rate with the rate set by the command list.</td></tr>
<tr><td>ShadingRateCombiner shadingRateCombiner2</td><td>ShadingRateCombiner::PassThrough</td><td>For variable rate shading. This combines the image based shading rate with the shading rate set by the command list and provoking vertex.</td></tr>
<tr><td>NodePinReferenceOptional shadingRateImage</td><td>{}</td><td>The image used to determine shading rate on the screen. Must be a 2d texture with format R8_Uint.</td></tr>
<tr><td>NodePinReferenceOptional vertexBuffer</td><td>{}</td><td>The vertex buffer being rendered. If not given, a vertexCount needs to be given.</td></tr>
<tr><td>NodePinReferenceOptional indexBuffer</td><td>{}</td><td>Index buffer for vertex buffer (Optional).</td></tr>
<tr><td>NodePinReferenceOptional instanceBuffer</td><td>{}</td><td>Instance buffer (Optional).</td></tr>
<tr><td>NodePinReferenceOptional colorTargets[8]</td><td>{}</td><td>Color Targets</td></tr>
<tr><td>NodePinReferenceOptional depthTarget</td><td>{}</td><td>Depth Target</td></tr>
<tr><td>GeometryType geometryType</td><td>GeometryType::TriangleList</td><td>What to draw</td></tr>
</table>
<br/>

<b>RenderGraphNode_Action_SubGraph : Runs another Gigi technique</b><br/><br/>
<table>
<tr><th colspan=3>RenderGraphNode_Action_SubGraph - Inherits from RenderGraphNode_ActionBase</th></tr>
<tr><td><b>inline static const std::string c_editorName</b></td><td>"Subgraph"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shortTypeName</b></td><td>"Subgraph"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shorterTypeName</b></td><td>"Sub"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const bool c_showInEditor</b></td><td>true</td><td>Used by the editor.</td></tr>
<tr><td>std::string fileName</td><td>""</td><td>Relative file name</td></tr>
<tr><td>SubGraphData subGraphData</td><td>{}</td><td>A cache of the interface of the other graph.</td></tr>
<tr><td>SubGraphVariableSettings variableSettings[]</td><td></td><td>Per variable settings for subgraph variables.</td></tr>
<tr><td>int loopCount</td><td>1</td><td>Number of times to execute the technique.</td></tr>
<tr><td>VariableReferenceConstOnly loopCountVariable</td><td>{}</td><td>The variable to use for the loopCount. Only const variables supported currently.</td></tr>
<tr><td><i>int loopIndex</i></td><td>-1</td><td>When unrolling subgraph loops, the loop index of the node is stored here.</td></tr>
</table>
<br/>

<b>RenderGraphNode_Action_Barrier : Causes all input operations to be executed before anything plugged into the output</b><br/><br/>
<table>
<tr><th colspan=3>RenderGraphNode_Action_Barrier - Inherits from RenderGraphNode_ActionBase</th></tr>
<tr><td><b>inline static const std::string c_editorName</b></td><td>"Barrier"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shortTypeName</b></td><td>"Barrier"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const std::string c_shorterTypeName</b></td><td>"Bar"</td><td>Used by the editor.</td></tr>
<tr><td><b>inline static const bool c_showInEditor</b></td><td>true</td><td>Used by the editor.</td></tr>
</table>
<br/>

<b>PreviewMsg_Ping : The client and server send this periodically to know the other is still alive. It fails to send if the connection closes.</b><br/><br/>
<table>
<tr><th colspan=3>PreviewMsg_Ping</th></tr>
</table>
<br/>

<b>PreviewMsgCS_Version : The client tells the server what Gigi version it is using</b><br/><br/>
<table>
<tr><th colspan=3>PreviewMsgCS_Version</th></tr>
<tr><td>std::string version</td><td>""</td><td>Gigi Version</td></tr>
</table>
<br/>

<b>PreviewMsgCS_Log : The client tells the server what Gigi version it is using</b><br/><br/>
<table>
<tr><th colspan=3>PreviewMsgCS_Log</th></tr>
<tr><td>PreviewMsgCS_Log_Level level</td><td>PreviewMsgCS_Log_Level::Info</td><td>The type of message</td></tr>
<tr><td>std::string msg</td><td>""</td><td>The log message</td></tr>
</table>
<br/>

<b>PreviewMsgSC_VersionResponse : The server tells the client whether or not the version is ok.</b><br/><br/>
<table>
<tr><th colspan=3>PreviewMsgSC_VersionResponse</th></tr>
<tr><td>bool versionOK</td><td>false</td><td>Whether the gigi version is ok or not.</td></tr>
</table>
<br/>

<b>PreviewMsgSC_LoadGGFile : The client tells the server to load a gg file</b><br/><br/>
<table>
<tr><th colspan=3>PreviewMsgSC_LoadGGFile</th></tr>
<tr><td>std::string fileName</td><td>""</td><td>The path and name of the .gg file to load</td></tr>
<tr><td>bool preserveState</td><td>true</td><td>If true, camera state etc should be preserved</td></tr>
</table>
<br/>

<b>GGUserFile_ImportedTexture : The details of an imported texture</b><br/><br/>
<table>
<tr><th colspan=3>GGUserFile_ImportedTexture</th></tr>
<tr><td>std::string fileName</td><td>""</td><td>The image file loaded</td></tr>
<tr><td>bool fileIsSRGB</td><td>true</td><td>Whether the file is an sRGB file or not</td></tr>
<tr><td>bool makeMips</td><td>false</td><td>Whether to make mips or no</td></tr>
<tr><td>int size[3]</td><td>{0 , 0 , 1}</td><td>The size of the image to create</td></tr>
<tr><td>float color[4]</td><td>{ 1 , 1 , 1 , 1}</td><td>The color of the image to create, or the tint of the loaded file</td></tr>
<tr><td>TextureFormat format</td><td>TextureFormat::RGBA8_Unorm_sRGB</td><td>The format of the texture to create</td></tr>
<tr><td>int binaryDims[3]</td><td>{0 , 0 , 1}</td><td>The size of the image in the binary file</td></tr>
<tr><td>TextureFormat binaryFormat</td><td>TextureFormat::RGBA8_Unorm_sRGB</td><td>The format of the binary file</td></tr>
</table>
<br/>

<b>GGUserFile_ImportedBuffer : The details of an imported buffer</b><br/><br/>
<table>
<tr><th colspan=3>GGUserFile_ImportedBuffer</th></tr>
<tr><td>std::string fileName</td><td>""</td><td>The file loaded</td></tr>
<tr><td>bool CSVHeaderRow</td><td>true</td><td>If reading a CSV, and this is true, it will skip everything up to the first newline, to ignore a header row.</td></tr>
<tr><td>int structIndex</td><td>-1</td><td>the index of the struct if a structured buffer</td></tr>
<tr><td>DataFieldType type</td><td>DataFieldType::Count</td><td>The data field type, if not a structured buffer</td></tr>
<tr><td>int count</td><td>1</td><td>how many items are stored</td></tr>
<tr><td>GGUserFile_TLASBuildFlags RT_BuildFlags</td><td>GGUserFile_TLASBuildFlags::PreferFastTrace</td><td>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_PREFER_FAST_TRACE etc</td></tr>
<tr><td>bool BLASOpaque</td><td>false</td><td>DXR BLAS Option</td></tr>
<tr><td>bool BLASNoDuplicateAnyhitInvocations</td><td>false</td><td>DXR BLAS Option</td></tr>
<tr><td>bool IsAABBs</td><td>false</td><td>Set to true if ray tracing AABBs with intersection shaders. Format is Min XYZ, Max XYZ.</td></tr>
</table>
<br/>

<b>GGUserFile_ImportedResource : The details of an imported resource</b><br/><br/>
<table>
<tr><th colspan=3>GGUserFile_ImportedResource</th></tr>
<tr><td>std::string nodeName</td><td>""</td><td>The name of the node this imported texture data is for</td></tr>
<tr><td>bool resetEveryFrame</td><td>true</td><td>Whether this texture should be reset every frame, or if the technique is allowed to change it over multiple frames</td></tr>
<tr><td>bool isATexture</td><td>true</td><td>Is it a texture or a buffer</td></tr>
<tr><td>GGUserFile_ImportedTexture texture</td><td>{}</td><td>Texture data</td></tr>
<tr><td>GGUserFile_ImportedBuffer buffer</td><td>{}</td><td>Buffer data</td></tr>
</table>
<br/>

<b>GGUserFile_Camera : </b><br/><br/>
<table>
<tr><th colspan=3>GGUserFile_Camera</th></tr>
<tr><td>bool perspective</td><td>true</td><td>Perspective if true, orthographic if false.</td></tr>
<tr><td>bool leftHanded</td><td>true</td><td>Left handed if true, right handed if false.</td></tr>
<tr><td>bool reverseZ</td><td>true</td><td>If true, reverses the depth values for more precision. https://developer.nvidia.com/content/depth-precision-visualized</td></tr>
<tr><td>float nearPlane</td><td>0.1f</td><td>The distance to the near plane.</td></tr>
<tr><td>float farPlane</td><td>1000.0f</td><td>The distance to the far plane. Set to zero for infinite Z.</td></tr>
<tr><td>float FOV</td><td>45.0f</td><td>Vertical field of view, in degrees</td></tr>
<tr><td>float flySpeed</td><td>0.1f</td><td>How fast the WASD keys move in the world</td></tr>
<tr><td>float mouseSensitivity</td><td>0.01f</td><td>How fast the mouse rotates the camera</td></tr>
<tr><td>GGUserFile_CameraJitterType jitterType</td><td>GGUserFile_CameraJitterType::Halton23</td><td>The sequence of the jittered projection matrix</td></tr>
<tr><td>int jitterLength</td><td>16</td><td>The length of the sequence used to jitter the jittered projection matrix. 0 means infinite.</td></tr>
<tr><td>float startingCameraPos[3]</td><td>{ 0.0f , 0.0f , -10.0f }</td><td></td></tr>
<tr><td>float startingCameraAltitudeAzimuth[2]</td><td>{ 0.0f , 0.0f }</td><td></td></tr>
<tr><td><i>float cameraPos[3]</i></td><td>{0.0f , 0.0f , -10.0f}</td><td></td></tr>
<tr><td><i>float cameraAltitudeAzimuth[2]</i></td><td>{0.0f , 0.0f}</td><td></td></tr>
<tr><td><i>bool cameraChanged</i></td><td>false</td><td></td></tr>
</table>
<br/>

<b>GGUserFile_SystemVars : </b><br/><br/>
<table>
<tr><th colspan=3>GGUserFile_SystemVars</th></tr>
<tr><td>std::string iResolution_varName</td><td>"iResolution"</td><td></td></tr>
<tr><td>std::string iResolution_textureName</td><td>""</td><td></td></tr>
<tr><td>std::string iTime_varName</td><td>"iTime"</td><td></td></tr>
<tr><td>std::string iTimeDelta_varName</td><td>"iTimeDelta"</td><td></td></tr>
<tr><td>std::string iFrameRate_varName</td><td>"iFrameRate"</td><td></td></tr>
<tr><td>std::string iFrame_varName</td><td>"iFrame"</td><td></td></tr>
<tr><td>std::string iMouse_varName</td><td>"iMouse"</td><td></td></tr>
<tr><td>std::string MouseState_varName</td><td>"MouseState"</td><td></td></tr>
<tr><td>std::string MouseStateLastFrame_varName</td><td>"MouseStateLastFrame"</td><td></td></tr>
<tr><td>std::string WindowSize_varName</td><td>"WindowSize"</td><td></td></tr>
<tr><td>GGUserFile_Camera camera</td><td>{}</td><td>The camera settings. Can pluralize if one isn't enough.</td></tr>
<tr><td>std::string ProjMtx_textureName</td><td>""</td><td>The projection matrix needs a resolution to calculate for. Choose a texture node and that will be used as a resolution.</td></tr>
<tr><td>std::string ViewMtx_varName</td><td>"ViewMtx"</td><td></td></tr>
<tr><td>std::string InvViewMtx_varName</td><td>"InvViewMtx"</td><td></td></tr>
<tr><td>std::string ProjMtx_varName</td><td>"ProjMtx"</td><td></td></tr>
<tr><td>std::string InvProjMtx_varName</td><td>"InvProjMtx"</td><td></td></tr>
<tr><td>std::string ViewProjMtx_varName</td><td>"ViewProjMtx"</td><td></td></tr>
<tr><td>std::string InvViewProjMtx_varName</td><td>"InvViewProjMtx"</td><td></td></tr>
<tr><td>std::string JitteredProjMtx_varName</td><td>"JitteredProjMtx"</td><td>ProjMtx with jitter.</td></tr>
<tr><td>std::string InvJitteredProjMtx_varName</td><td>"InvJitteredProjMtx"</td><td>Inverted ProjMtx with jitter.</td></tr>
<tr><td>std::string JitteredViewProjMtx_varName</td><td>"JitteredViewProjMtx"</td><td>ViewProjMtx with jitter.</td></tr>
<tr><td>std::string InvJitteredViewProjMtx_varName</td><td>"InvJitteredViewProjMtx"</td><td>Inverted ViewProjMtx with jitter.</td></tr>
<tr><td>std::string CameraPos_varName</td><td>"CameraPos"</td><td></td></tr>
<tr><td>std::string CameraAltitudeAzimuth_varName</td><td>"CameraAltitudeAzimuth"</td><td></td></tr>
<tr><td>std::string CameraChanged_varName</td><td>"CameraChanged"</td><td></td></tr>
<tr><td>std::string CameraJitter_varName</td><td>"CameraJitter"</td><td></td></tr>
<tr><td>std::string CameraFOV_varName</td><td>"CameraFOV"</td><td></td></tr>
<tr><td>std::string CameraNearPlane_varName</td><td>"CameraNearPlane"</td><td></td></tr>
<tr><td>std::string CameraFarPlane_varName</td><td>"CameraFarPlane"</td><td></td></tr>
<tr><td>std::string ShadingRateImageTileSize_varName</td><td>"ShadingRateImageTileSize"</td><td></td></tr>
<tr><td>std::string KeyState_bufferName</td><td>""</td><td>256 entries for the keys this frame, and 256 entries for the keys last frame. 512 entries total.</td></tr>
</table>
<br/>

<b>GGUserFile_SavedVariable : Saved Variable Values</b><br/><br/>
<table>
<tr><th colspan=3>GGUserFile_SavedVariable</th></tr>
<tr><td>std::string name</td><td>""</td><td></td></tr>
<tr><td>std::string value</td><td>""</td><td></td></tr>
</table>
<br/>

<b>GGUserFileV1 : The contents of a .gguser file</b><br/><br/>
<table>
<tr><th colspan=3>GGUserFileV1</th></tr>
<tr><td>std::string version</td><td>"1.0"</td><td>The version of the .gguser file</td></tr>
<tr><td>GGUserFile_SystemVars systemVars</td><td>{}</td><td></td></tr>
<tr><td>int resourceViewType</td><td>0</td><td>The type of resource being viewed</td></tr>
<tr><td>int resourceViewNodeIndex</td><td>-1</td><td>The index of the node bieng viewed</td></tr>
<tr><td>int resourceViewResourceIndex</td><td>-1</td><td>The index of that resource within that node being used</td></tr>
<tr><td>int syncInterval</td><td>1</td><td>IDXGISwapChain::Present() parameter: Synchronize presentation after the nth vertical blank.</td></tr>
<tr><td>GGUserFile_ImportedResource importedResources[]</td><td></td><td></td></tr>
<tr><td>GGUserFile_SavedVariable savedVariables[]</td><td></td><td></td></tr>
</table>
<br/>

<b>GGUserFileV2Snapshot : The snapshot of a GGUserFileV2</b><br/><br/>
<table>
<tr><th colspan=3>GGUserFileV2Snapshot</th></tr>
<tr><td>std::string name</td><td>""</td><td>The snapshot name</td></tr>
<tr><td>int resourceViewType</td><td>0</td><td>The type of resource being viewed</td></tr>
<tr><td>int resourceViewNodeIndex</td><td>-1</td><td>The index of the node bieng viewed</td></tr>
<tr><td>int resourceViewResourceIndex</td><td>-1</td><td>The index of that resource within that node being used</td></tr>
<tr><td>bool loadVars</td><td>true</td><td>Whether variables will be loaded from this snapshot</td></tr>
<tr><td>bool loadCamera</td><td>true</td><td>Whether the camera will be loaded from this snapshot</td></tr>
<tr><td>bool loadResources</td><td>true</td><td>Whether imported resources will be loaded from this snapshot</td></tr>
<tr><td>bool loadView</td><td>true</td><td>Whether the resource viewed will be loaded from this snapshot</td></tr>
<tr><td>float cameraPos[3]</td><td>{ 0.0f , 0.0f , - 10.0f }</td><td>Used by snapshots to capture the camera position</td></tr>
<tr><td>float cameraAltitudeAzimuth[2]</td><td>{ 0.0f , 0.0f }</td><td>Used by snapshots to capture the camera orientation</td></tr>
<tr><td>GGUserFile_ImportedResource importedResources[]</td><td></td><td></td></tr>
<tr><td>GGUserFile_SavedVariable savedVariables[]</td><td></td><td></td></tr>
</table>
<br/>

<b>GGUserFileV2 : The contents of a .gguser file</b><br/><br/>
<table>
<tr><th colspan=3>GGUserFileV2</th></tr>
<tr><td>std::string version</td><td>"2.0"</td><td>The version of the .gguser file</td></tr>
<tr><td>int syncInterval</td><td>1</td><td>IDXGISwapChain::Present() parameter: Synchronize presentation after the nth vertical blank.</td></tr>
<tr><td>GGUserFile_SystemVars systemVars</td><td>{}</td><td></td></tr>
<tr><td>GGUserFileV2Snapshot snapshot</td><td>{}</td><td></td></tr>
<tr><td>GGUserFileV2Snapshot snapshots[]</td><td></td><td></td></tr>
</table>
<br/>

<b>GGUserFileVersionOnly : Only the version of the .gguser file</b><br/><br/>
<table>
<tr><th colspan=3>GGUserFileVersionOnly</th></tr>
<tr><td>std::string version</td><td>"1.0"</td><td>The version of the .gguser file</td></tr>
</table>
<br/>

<b>BrowserServerInfo : </b><br/><br/>
<table>
<tr><th colspan=3>BrowserServerInfo</th></tr>
<tr><td>std::string Name</td><td>""</td><td></td></tr>
<tr><td>std::string Repo</td><td>""</td><td></td></tr>
<tr><td>std::string Branch</td><td>""</td><td></td></tr>
<tr><td>std::string TechniqueList</td><td>""</td><td></td></tr>
</table>
<br/>

<b>BrowserTechniqueSummary : </b><br/><br/>
<table>
<tr><th colspan=3>BrowserTechniqueSummary</th></tr>
<tr><td>std::string Repo</td><td>""</td><td>The repo. Usually begins with https and ends with .git.</td></tr>
<tr><td>std::string Commit</td><td>""</td><td>The commit hash to look at in that repo.</td></tr>
<tr><td>std::string DetailsFile</td><td>""</td><td>The path of the json file containing BrowserTechniqueDetails of the technique. This location is recursively downloaded when the download button is pressed.</td></tr>
<tr><td>std::string ListedDate</td><td>""</td><td>A date in the form YYYY-MM-DD</td></tr>
</table>
<br/>

<b>BrowserTechniqueSummaries : </b><br/><br/>
<table>
<tr><th colspan=3>BrowserTechniqueSummaries</th></tr>
<tr><td>BrowserTechniqueSummary Techniques[]</td><td></td><td></td></tr>
</table>
<br/>

<b>BrowserTechniqueDetails : </b><br/><br/>
<table>
<tr><th colspan=3>BrowserTechniqueDetails</th></tr>
<tr><td>std::string Title</td><td>""</td><td></td></tr>
<tr><td>std::string Description</td><td>""</td><td></td></tr>
<tr><td>std::string Author</td><td>""</td><td></td></tr>
<tr><td>std::string Tags</td><td>""</td><td>Separated by commas</td></tr>
<tr><td>std::string Technique</td><td>"The .gg file to open. Relative to DetailsFile."</td><td></td></tr>
<tr><td>std::string Website</td><td>""</td><td>[Optional] A website to view and/or discuss your technique. For instance, the github page.</td></tr>
<tr><td>std::string Screenshot</td><td>""</td><td>The image shown that goes with your technique. Relative to DetailsFile.</td></tr>
<tr><td>std::string License</td><td>""</td><td>The file describing the license of your technique. Relative to DetailsFile.</td></tr>
<tr><td>std::string GigiVersion</td><td>""</td><td>The version of Gigi used to make this technique.</td></tr>
</table>
<br/>

<b>BrowserCachedTechnique : </b><br/><br/>
<table>
<tr><th colspan=3>BrowserCachedTechnique</th></tr>
<tr><td>BrowserTechniqueSummary Summary</td><td>{}</td><td></td></tr>
<tr><td>BrowserTechniqueDetails Details</td><td>{}</td><td></td></tr>
<tr><td>bool Downloaded</td><td>false</td><td></td></tr>
<tr><td>BrowserServerInfo Origin</td><td>{}</td><td></td></tr>
</table>
<br/>

<b>BrowserCachedTechniques : </b><br/><br/>
<table>
<tr><th colspan=3>BrowserCachedTechniques</th></tr>
<tr><td>BrowserCachedTechnique Techniques[]</td><td></td><td></td></tr>
</table>
<br/>

<b>BackendTemplateFileProperties : File Properties</b><br/><br/>
<table>
<tr><th colspan=3>BackendTemplateFileProperties</th></tr>
<tr><td>std::string fileName</td><td>""</td><td>The name of the file this is the properties for.</td></tr>
<tr><td>std::string renameTo</td><td>""</td><td>If not blank, what to rename the file to. May use the /*$(Name)*/ Gigi token.</td></tr>
<tr><td>bool isDirectory</td><td>false</td><td>If this is a directory, set this to true to make this apply to all files in the directory recursively.</td></tr>
<tr><td>bool onlyIncludeIfRaytracing</td><td>false</td><td>If a file should only be copied when the render graph uses raytracing, set this to true.</td></tr>
<tr><td>bool onlyIncludeIfDX12AgilitySDKRequired</td><td>false</td><td>If a file should only be copied when the dx12 agility sdk is required, set this to true</td></tr>
</table>
<br/>

<b>BackendTemplateNodeTemplate : Template text for specific tags, for specific nodes</b><br/><br/>
<table>
<tr><th colspan=3>BackendTemplateNodeTemplate</th></tr>
<tr><td>std::string nodeType</td><td>""</td><td>The type of node this template is for.</td></tr>
<tr><td>std::string tag</td><td>""</td><td>The tag that this template is for.</td></tr>
<tr><td>std::string text</td><td>""</td><td>The text body of the template</td></tr>
</table>
<br/>

<b>BackendTemplateConfig : Backend Template Config</b><br/><br/>
<table>
<tr><th colspan=3>BackendTemplateConfig</th></tr>
<tr><td>BackendTemplateFileProperties fileProperties[]</td><td></td><td>Properties for files in a backend template directory</td></tr>
<tr><td>std::string ignoreDirectories[]</td><td></td><td>Do not process a directory as template files</td></tr>
<tr><td>std::string nodeTemplateFiles[]</td><td></td><td>The files to process into node templates</td></tr>
<tr><td><i>BackendTemplateNodeTemplate nodeTemplates[]</i></td><td></td><td>calculated at runtime, from nodeTemplateFiles</td></tr>
</table>
<br/>

<b>BackendSettings_DX12 : DX12 Settings</b><br/><br/>
<table>
<tr><th colspan=3>BackendSettings_DX12</th></tr>
<tr><td>int numSRVDescriptors</td><td>256</td><td>The number of descriptors in the internal SRV heap</td></tr>
<tr><td>int numRTVDescriptors</td><td>256</td><td>The number of descriptors in the internal RTV heap</td></tr>
<tr><td>int numDSVDescriptors</td><td>256</td><td>The number of descriptors in the internal DSV heap</td></tr>
<tr><td>DXShaderCompiler shaderCompiler</td><td>DXShaderCompiler::DXC</td><td>The shader compiler to use</td></tr>
<tr><td>std::string shaderModelCs</td><td>"cs_6_1"</td><td>The default shader model to use for compute shaders</td></tr>
<tr><td>std::string shaderModelVs</td><td>"vs_6_1"</td><td>The default shader model to use for vertex shaders</td></tr>
<tr><td>std::string shaderModelPs</td><td>"ps_6_1"</td><td>The default shader model to use for pixel shaders</td></tr>
<tr><td>std::string shaderModelRayShaders</td><td>"lib_6_3"</td><td>The default shader model to use for ray shaders</td></tr>
<tr><td>std::string shaderModelAs</td><td>"as_6_5"</td><td>The default shader model to use for amplification shaders</td></tr>
<tr><td>std::string shaderModelMs</td><td>"ms_6_5"</td><td>The default shader model to use for mesh shaders</td></tr>
<tr><td>bool DXC_HLSL_2021</td><td>false</td><td>When using DXC, use HLSL 2021.  https://github.com/microsoft/DirectXShaderCompiler/wiki/HLSL-2021</td></tr>
<tr><td>bool AgilitySDKRequired</td><td>false</td><td>True if the agility SDK is required in DX12. Can be set to true in the editor, but can also be set to true by the compiler.</td></tr>
</table>
<br/>

<b>BackendSettings_Common : Common Settings</b><br/><br/>
<table>
<tr><th colspan=3>BackendSettings_Common</th></tr>
<tr><td>bool debugNames</td><td>true</td><td>If true, sets debug names to GPU objects on available platforms.</td></tr>
<tr><td>bool debugShaders</td><td>true</td><td>If true, compiles shaders with debug options turned on, on available platforms.</td></tr>
</table>
<br/>

<b>BackendSettings : Backend settings</b><br/><br/>
<table>
<tr><th colspan=3>BackendSettings</th></tr>
<tr><td>BackendSettings_DX12 dx12</td><td>{}</td><td></td></tr>
<tr><td>BackendSettings_Common common</td><td>{}</td><td></td></tr>
</table>
<br/>

<b>BuildSettings : Backend settings</b><br/><br/>
<table>
<tr><th colspan=3>BuildSettings</th></tr>
<tr><td>GigiCompileWarning disableWarnings[]</td><td></td><td>Warnings listed here will be suppressed</td></tr>
<tr><td>std::string outDX12</td><td>"out/dx12/"</td><td>The output location for DX12</td></tr>
<tr><td><i>std::string outInterpreter</i></td><td>"out/interpreter/"</td><td>The output location for the interpreter backend</td></tr>
</table>
<br/>

<b>ConfigFromBackend : Frontend configuration set by the backend.</b><br/><br/>
<table>
<tr><th colspan=3>ConfigFromBackend</th></tr>
<tr><td>bool RTSceneTakesSRVSlot</td><td>true</td><td>If true, RT scenes will take an SRV register slot.</td></tr>
</table>
<br/>

<b>ResourceTransition : A single resource transition</b><br/><br/>
<table>
<tr><th colspan=3>ResourceTransition</th></tr>
<tr><td>int nodeIndex</td><td>-1</td><td>The node for the resource being transitioned.</td></tr>
<tr><td>ShaderResourceAccessType oldState</td><td>ShaderResourceAccessType::Count</td><td>The previous state</td></tr>
<tr><td>ShaderResourceAccessType newState</td><td>ShaderResourceAccessType::Count</td><td>The next state</td></tr>
</table>
<br/>

<b>ResourceTransitions : A list of resource transitions</b><br/><br/>
<table>
<tr><th colspan=3>ResourceTransitions</th></tr>
<tr><td>ResourceTransition transitions[]</td><td></td><td>A list of resource transitions</td></tr>
</table>
<br/>

<b>FileCopy : A description of a file to copy into the output package</b><br/><br/>
<table>
<tr><th colspan=3>FileCopy</th></tr>
<tr><td>std::string fileName</td><td>""</td><td>The file to copy.</td></tr>
<tr><td>FileCopyType type</td><td>FileCopyType::Private</td><td>The type of file it is</td></tr>
<tr><td>std::string destFileName</td><td>""</td><td>If empty, uses fileName</td></tr>
<tr><td>BackendRestriction backends</td><td>{}</td><td>The backends this file copy happens for.</td></tr>
<tr><td>bool binary</td><td>false</td><td>If false, it will be treated as a text file, undergo string replacement, and line ending normalization. If true, it will be copied without modification.</td></tr>
<tr><td>bool plural</td><td>false</td><td>If true, this file copy is a file pattern for possibly several files to copy.  The filename should contain a %i and all files from 0 to N at that location in the file name will be copied.</td></tr>
</table>
<br/>

<b>SetVariable : A variable modification</b><br/><br/>
<table>
<tr><th colspan=3>SetVariable</th></tr>
<tr><td>VariableReferenceNoConst destination</td><td>{}</td><td>The variable to set.  destination = A (operator) B.</td></tr>
<tr><td>int destinationIndex</td><td>-1</td><td>The index of the field in the destination variable. -1 means no index.</td></tr>
<tr><td>VariableReference AVar</td><td>{}</td><td>The variable on the left side of the operator</td></tr>
<tr><td>int AVarIndex</td><td>-1</td><td>The index of the field in the A variable. -1 means no index.</td></tr>
<tr><td>TextureOrBufferNodeReference ANode</td><td>{}</td><td>If specified, the size of this resource will be used. AVarIndex will index into it if multi dimensional.</td></tr>
<tr><td>std::string ALiteral</td><td>""</td><td>The value to use, if no variable is set</td></tr>
<tr><td>SetVariableOperator op</td><td>SetVariableOperator::Add</td><td></td></tr>
<tr><td>VariableReference BVar</td><td>{}</td><td>The variable on the right side of the operator</td></tr>
<tr><td>int BVarIndex</td><td>-1</td><td>The index of the field in the B variable. -1 means no index.</td></tr>
<tr><td>TextureOrBufferNodeReference BNode</td><td>{}</td><td>If specified, the size of this resource will be used. BVarIndex will index into it if multi dimensional.</td></tr>
<tr><td>std::string BLiteral</td><td>""</td><td>The value to use, if no variable is set</td></tr>
<tr><td>bool setBefore</td><td>true</td><td>If true, this happens before execution. If false, happens after execution.</td></tr>
<tr><td>Condition condition</td><td>{}</td><td>An optional condition added for the action to happen</td></tr>
</table>
<br/>

<b>VariableReplacement : When subgraph variables are replaced by parent variables, this gives the breadcrumbs needed to find that.</b><br/><br/>
<table>
<tr><th colspan=3>VariableReplacement</th></tr>
<tr><td>std::string srcScope</td><td>""</td><td></td></tr>
<tr><td>std::string srcName</td><td>""</td><td></td></tr>
<tr><td>std::string destName</td><td>""</td><td></td></tr>
</table>
<br/>

<b>CustomGigiToken : Allows you to give values for custom gigi tokens, such as /*$(CopyrightHeader)*/. All unknown Gigi tokens are replaced with empty string by default.</b><br/><br/>
<table>
<tr><th colspan=3>CustomGigiToken</th></tr>
<tr><td>std::string key</td><td>""</td><td>The name of the gigi token without markup, such as CopyrightHeader for /*$(CopyrightHeader)*/</td></tr>
<tr><td>std::string value</td><td>""</td><td>The value to replace the token with</td></tr>
</table>
<br/>

<b>EditorGroupNode : Data for group nodes in the editor</b><br/><br/>
<table>
<tr><th colspan=3>EditorGroupNode</th></tr>
<tr><td>std::string name</td><td>""</td><td>Name of the group</td></tr>
<tr><td><i>int32_t id</i></td><td>0</td><td>Id of the group</td></tr>
<tr><td>float position[2]</td><td>{ 0.f , 0.f }</td><td>Position of the group</td></tr>
<tr><td>float size[2]</td><td>{ 0.f , 0.f }</td><td>Size of the group</td></tr>
<tr><td>float color[4]</td><td>{ 1.f , 1.f , 1.f , 0.25f }</td><td>Color of the group</td></tr>
</table>
<br/>

<b>RenderGraph : The root type of the render graph</b><br/><br/>
<table>
<tr><th colspan=3>RenderGraph</th></tr>
<tr><td>std::string name</td><td>"Unnamed"</td><td>The name of the render graph.</td></tr>
<tr><td>std::string comment</td><td>""</td><td>Put author information, links, etc here.</td></tr>
<tr><td>std::string version</td><td>""</td><td>The gigi version of the render graph.</td></tr>
<tr><td><i>std::string schema</i></td><td>""</td><td>The schema file read from the file originally, so we can put it back as it was.</td></tr>
<tr><td>Variable variables[]</td><td></td><td>The render graph variables. Used for getting parameters from the host app and user. Can be referenced by many things in the render graph such as texture size and shader constants.</td></tr>
<tr><td>Shader shaders[]</td><td></td><td>The shaders used by the render graph.</td></tr>
<tr><td>Struct structs[]</td><td></td><td>The structs used by the render graph.</td></tr>
<tr><td>FileCopy fileCopies[]</td><td></td><td>Files to copy during the building process.</td></tr>
<tr><td>RenderGraphNode nodes[]</td><td></td><td>The render graph nodes.</td></tr>
<tr><td>Enum enums[]</td><td></td><td>Enums</td></tr>
<tr><td>SetVariable setVars[]</td><td></td><td>Variables to modify at the beginning or end of the render graph</td></tr>
<tr><td>RTHitGroup hitGroups[]</td><td></td><td>Ray tracing hit group definitions</td></tr>
<tr><td>BackendSettings settings</td><td>{}</td><td>Backend settings</td></tr>
<tr><td>BuildSettings buildSettings</td><td>{}</td><td>Build settings</td></tr>
<tr><td>CustomGigiToken customTokens[]</td><td></td><td>Allows you to give values for custom gigi tokens, such as /*$(CopyrightHeader)*/. All unknown Gigi tokens are replaced with empty string by default.</td></tr>
<tr><td>TextureNodeReference PrimaryOutput</td><td>{}</td><td>A hint to anything that might be able to use this information, such as generated code or the viewer.</td></tr>
<tr><td>EditorGroupNode editorGroupNodes[]</td><td></td><td>Editor group nodes</td></tr>
<tr><td><i>std::string baseDirectory</i></td><td>""</td><td>The relative location of the render graph file.</td></tr>
<tr><td><i>std::string outputDirectory</i></td><td>""</td><td>Where the render graph output should go (this field used by the compiler).</td></tr>
<tr><td><i>std::vector<int> flattenedNodeList</i></td><td>{}</td><td>The flattened list of nodes, in the order they should be executed in. Calculated before being given to back end code.</td></tr>
<tr><td><i>std::vector<ResourceTransitions> transitions</i></td><td>{}</td><td>The resource transitions that want to happen before each node executes. Calculated before being given to back end code.</td></tr>
<tr><td><i>Backend backend</i></td><td>Backend::DX12</td><td>The backend currently being ran</td></tr>
<tr><td><i>ConfigFromBackend configFromBackend</i></td><td>{}</td><td>Information communicated to the front end, by the back end.</td></tr>
<tr><td><i>bool usesRaytracing</i></td><td>false</td><td>True if this render graph uses ray tracing.</td></tr>
<tr><td><i>std::string editorFileName</i></td><td>""</td><td>The name and path of the file name in the editor</td></tr>
<tr><td><i>std::string subGGGraphFileNames[]</i></td><td></td><td>The list of absolute path sugraph gg files this render graph relies on. Useful for file watches from the viewer.</td></tr>
<tr><td><i>VariableReplacement variableReplacements[]</i></td><td></td><td>When subgraph variables are replaced by parent variables, this gives the breadcrumbs needed to find that.</td></tr>
<tr><td><i>bool versionUpgraded</i></td><td>false</td><td>Set to true if the loading code did a version upgrade. The editor uses this to mark the document as dirty.</td></tr>
<tr><td><i>std::string versionUpgradedFrom</i></td><td>""</td><td>The version it was upgraded from</td></tr>
<tr><td><i>std::string versionUpgradedMessage</i></td><td>""</td><td>Text to show about the version upgrade</td></tr>
<tr><td><i>BackendTemplateConfig templateConfig</i></td><td>{}</td><td>Code generation template config</td></tr>
<tr><td><i>bool generateGraphVizFlag</i></td><td>false</td><td>Set to true if the generating GraphViz. Should be set to true from a command line parameter</td></tr>
<tr><td><i>std::vector<std::string> assertsFormatStrings</i></td><td>{}</td><td>The unique formatting strings of the asserts messages</td></tr>
<tr><td><i>std::unordered_set<std::string> firedAssertsIdentifiers</i></td><td>{}</td><td>The identifiers of the fired asserts to ignore them later on</td></tr>
</table>
<br/>


<h1>Variants</h1>
<b>RenderGraphNode : Render graph node variant</b><br/><br/>
<table>
<tr><th colspan=3>RenderGraphNode</th></tr>
<tr><td>RenderGraphNode_Resource_Buffer resourceBuffer</td><td>{}</td><td></td></tr>
<tr><td>RenderGraphNode_Resource_ShaderConstants resourceShaderConstants</td><td>{}</td><td></td></tr>
<tr><td>RenderGraphNode_Resource_Texture resourceTexture</td><td>{}</td><td></td></tr>
<tr><td>RenderGraphNode_Action_ComputeShader actionComputeShader</td><td>{}</td><td></td></tr>
<tr><td>RenderGraphNode_Action_RayShader actionRayShader</td><td>{}</td><td></td></tr>
<tr><td>RenderGraphNode_Action_CopyResource actionCopyResource</td><td>{}</td><td></td></tr>
<tr><td>RenderGraphNode_Action_DrawCall actionDrawCall</td><td>{}</td><td></td></tr>
<tr><td>RenderGraphNode_Action_SubGraph actionSubGraph</td><td>{}</td><td></td></tr>
<tr><td>RenderGraphNode_Action_Barrier actionBarrier</td><td>{}</td><td></td></tr>
</table>
<br/>

<b>PreviewMsgClientToServer : Viewer client to server messages</b><br/><br/>
<table>
<tr><th colspan=3>PreviewMsgClientToServer</th></tr>
<tr><td>PreviewMsg_Ping ping</td><td>{}</td><td></td></tr>
<tr><td>PreviewMsgCS_Version version</td><td>{}</td><td></td></tr>
<tr><td>PreviewMsgCS_Log log</td><td>{}</td><td></td></tr>
</table>
<br/>

<b>PreviewMsgServerToClient : Viewer server to client messages</b><br/><br/>
<table>
<tr><th colspan=3>PreviewMsgServerToClient</th></tr>
<tr><td>PreviewMsg_Ping ping</td><td>{}</td><td></td></tr>
<tr><td>PreviewMsgSC_VersionResponse versionResponse</td><td>{}</td><td></td></tr>
<tr><td>PreviewMsgSC_LoadGGFile loadGGFile</td><td>{}</td><td></td></tr>
</table>
<br/>


</html>
